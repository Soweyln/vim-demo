$MASTER VIM THE PRACTICAL WAY$

- Bin

# About

  • Covers $essential$ Vim <
  • Covers $advanced$ Vim <
  • Covers many $useful tips$ <
  • $Helps$ you to be a Vim master <
  • Does $NOT$ make you a Vim master ($Practice$!) <
  • Covers only $small portion$ of Vim's power <
  • Vim is just $one$ part of the flow <

# What is Vim?

{{{ascii
TTTTTT EEEE X   X TTTTTT     EEEE DDD  III TTTTTT  OOO  RRRR
  TT   E     X X    TT       E    D  D  I    TT   O   O R   R
  TT   EEE    X     TT       EEE  D  D  I    TT   O   O RRRR
  TT   E     X X    TT       E    D  D  I    TT   O   O R R
  TT   EEEE X   X   TT       EEEE DDD  III   TT    OOO  R  RR
}}}

# How to Start?

  ## Touch Typing <
    • The foundation <
    • Practice more for $numbers and special characters$ <

  ## Vimtutor <
    • $ vimtutor <

  ## Minimal Config <
    • Minimal $.vimrc$ config to start with <

    {{{vim " .vimrc
    set nocompatible
    syntax on
    filetype plugin indent on }}}

# How to Start?

  ## Use Docker Image <
    • Install [Docker for Mac](https://download.docker.com/mac/stable/Docker.dmg) <
    • Run $docker run -it --rm --name vim shenbin04/vim$ to run image <
      ▸ Run $vim -u vimrc.min$ to use minimal config <
      ▸ Run $vim$ to use full config <
      ▸ Run $<C-c>$ to exit (we will lost all changes) <
      ▸ Run $<C-p><C-q>$ to detach <
      ▸ Run $docker attach vim$ to attach again <

  ## Use Vim Config <
    • Run $git clone https://github.com/shenbin04/vim-config.git ~/.vim$ <
    • Run $cd ~/.vim && make install$ <

# How to Start?

  • Vim has different modes: <
    ▸ Vim is in $Normal$ mode when it launches (typing in this mode is not what we normally expect). <
    ▸ Press $i$ to enter $Insert$ mode and we can start typing. <

  • How to quit Vim? <
    ▸ Press $<ESC>$ (twice or more), type $:q$ and press $<ENTER>$ <

# How to Start?

  • The very $essential commands$ to get started <

  | Command          | Description                                 | <
  | ---------------- | ------------------------------------------- |
  | $h$, $j$, $k$, $l$       | ^move^ %left%, %down%, %up%, %right%                  | <
  | :e {file}        | ^edit^ $file$ in window                         | <
  | :e {dir}         | ^open^ $dir$ in file browser                    | <
  | $w$                | ^move^ to the %next% $start of word$              | <
  | $b$                | ^move^ to the %previous% $start of word$          | <
  | $$$                | ^move^ to the $end of line$                     | <
  | $0$                | ^move^ to the $beginning of line$               | <
  | $gg$               | ^move^ to the $first line$                      | <
  | $G$                | ^move^ to the $last line$                       | <
  | [%n%]$gg$,[%n%]$G$       | ^move^ to $line$ %n%                              | <
  | $<C-d>$            | ^move^ $half page$ %down%                         | <
  | $<C-u>$            | ^move^ $half page$ %up%                           | <
  | $i$                | ^insert^ %before%                               | <
  | $a$                | ^append^ %after%                                | <
  | $<ESC>$            | ^return^ to $Normal$ mode                       | <
  | $dd$               | ^delete^ $current line$                         | <
  | $dw$               | ^delete^ %until next% $start of word$ (exclusive) | <
  | $u$                | ^undo^ $last edit$                              | <
  | $<C-r>$            | ^redo^ $last edit$                              | <
  | $yy$               | ^yank^ $current line$                           | <
  | $p$                | ^paste^ %after%                                 | <
  | :w               | ^write^ to $file$                               | <
  | :q               | ^quit^ $window$                                 | <
  | :q!              | ^quit^ $window$ (%discard changes%)               | <
  | $/${pattern}$<CR>$   | ^search^ %forward% for ${pattern}$                | <
  | $:%s$/old/new/[gc] | ^substitute^ in $buffer$                        | <

# How to Start?

  ## Use Help <

  | Command           | Description                             | <
  | ----------------- | --------------------------------------- |
  | $:h$elp             | ^open^ $help$                               | <
  | $:h$elp {$topic$}     | ^open^ $help$ for $topic$                     | <
  | $<C-]>$             | ^jump^ to $tag$                             | <
  | $<C-o>$             | ^jump^ %back%                               | <
  | $:helpg$rep {$topic$} | ^search^ $help$ for $topic$                   | <
  | $:h$elp $x$           | ^open^ $help$ for $x$ in %Normal% mode          | <
  | $:h$elp $v_x$         | ^open^ $help$ for $x$ in %Visual% mode          | <
  | $:h$elp $i_x$         | ^open^ $help$ for $x$ in %Insert% mode          | <
  | $:h$elp $:x$          | ^open^ $help$ for $x$ in %Command-line% command | <
  | $:h$elp $c_x$         | ^open^ $help$ for $x$ in %Command-line% editing | <
  | $:h$elp $-x$          | ^open^ $help$ for $x$ for %Command Argument%    | <
  | $:h$elp $'x'$         | ^open^ $help$ for $x$ for %Option%              | <
  | $:h$elp $/x$          | ^open^ $help$ for $x$ for %Regex%               | <

  • Use $<Tab>$ to autocomplete <
  • Check out $:h help-context$ and $:h help-summary$ <

# Why Vim?

  ## Efficiency <
    • No mouse, no ambiguity <
    • Powerful modal editing <
    • Designed for DRY (_Don't Repeat Yourself_) <

  ## Performance <
    • Fast & lightweight <

  ## Customization <
    • Config <
    • Plugin <
    • Script <
    • Integration <

  ## Documentation <
    • Comprehensive builtin documentation <

# Key Takeaways

  • $Count + Operator + Motion$ <

  • $Don't Repeat Yourself$ <

  • $Customize + Scripting$ <

# Contents

  • Modes <
  • Move <
  • Edit <
  • Visual <
  • Command <
  • Repeat <
  • Search <
  • Files <
  • Misc <
  • Config <
  • Plugin <
  • Script <
  • Thanks <

# Modes

  • Normal <
  • Insert <
  • Command-line <
  • Visual <
  • Operator-pending <
  • Replace <

# Modes > Switch between Modes

  • Vim is in $Normal$ mode when it launches. <
  • We can switch between different modes <

  | Command                    | Description                     | <
  | -------------------------- | ------------------------------- |
  | Normal + $a,A,C,i,I,o,O,s,S$ | ^switch^ to $Insert$ mode           | <
  | Normal + $:,/,?$             | ^switch^ to $Command-line$ mode     | <
  | Normal + $v,V,<C-v>$         | ^switch^ to $Visual$ mode           | <
  | Normal + $c,d,y$             | ^switch^ to $Operator-pending$ mode | <
  | Normal + $R$                 | ^switch^ to $Replace$ mode          | <
  | ANY + $<ESC>$                | ^switch^ to $Normal$ mode           | <

# Move

  • Moving around is one $crucial$ part of the flow when using Vim <
  • ^Avoid^ using $arrow keys$ to move <
  • ^Avoid^ move in $Insert$ mode <
  • Better to ^avoid^ using %repeated% $h/j/k/l$ to move <
  • Most moves can be ^repeated^ by $count$ <

# Move > Move by direction

  | Command | Description               | <
  | ------- | ------------------------- |
  | [%n%]$h$    | ^move^ %n% $character(s)$ %left%  | <
  | [%n%]$j$    | ^move^ %n% $line(s)$ %down%       | <
  | [%n%]$k$    | ^move^ %n% $line(s)$ %up%         | <
  | [%n%]$l$    | ^move^ %n% $character(s)$ %right% | <

  • $h/j/k/l$ can be repeated by $count$ <

# Move > Move by word

  • A $word$ is a sequence of letters, digits, understores or other non-blank characters. <
  • It can be customized with $iskeyword$. <
  • Move by $word$ is useful and much faster than move by single character. <

  | Command | Description                            | <
  | ------- | -------------------------------------- |
  | [%n%]$w$    | ^move^ to the %nth next% $start of word$     | <
  | [%n%]$b$    | ^move^ to the %nth previous% $start of word$ | <
  | [%n%]$e$    | ^move^ to the %nth next% $end of word$       | <
  | [%n%]$ge$   | ^move^ to the %nth previous% $end of word$   | <

# Move > Move by WORD

  • A $WORD$ is a sequence of $non-blank characters$ separated by white space. <
  • Move by $WORD$ is preferred in certain cases. <

  | Command | Description                            | <
  | ------- | -------------------------------------- |
  | [%n%]$W$    | ^move^ to the %nth next% $start of WORD$     | <
  | [%n%]$B$    | ^move^ to the %nth previous% $start of WORD$ | <
  | [%n%]$E$    | ^move^ to the %nth next% $end of WORD$       | <
  | [%n%]$gE$   | ^move^ to the %nth previous% $end of WORD$   | <

# Move > Move in line by line boundary

  • Move using $$$, $0$, $^$ is a quicker way to navigate to / between ends of current line. <

  | Command | Description                                               | <
  | ------- | --------------------------------------------------------- |
  | $0$       | ^move^ to the $beginning$ of line                             | <
  | $^$       | ^move^ to the $first non-blank character$ of line             | <
  | [%n%]$$$    | ^move^ to the $end$ of %(n-1)th next% line                      | <
  | [%n%]$g_$   | ^move^ to the $last non-blank character$ of %(n-1)th next% line | <

# Move > Move in line by finding character

  • Move using $f$, $t$ is a more precise way. <
  • Be aware of the $choice$ of {c}. <

  | Command | Description                                                      | <
  | ------- | ---------------------------------------------------------------- |
  | [%n%]$f{c}$ | ^move^ %to% the %nth next% $occurrence of {c}$ in line                   | <
  | [%n%]$t{c}$ | ^move^ %till% the %nth next% $occurrence of {c}$ in line (exclusive)     | <
  | [%n%]$F{c}$ | ^move^ %to% the %nth previous% $occurrence of {c}$ in line               | <
  | [%n%]$T{c}$ | ^move^ %till% the %nth previous% $occurrence of {c}$ in line (exclusive) | <
  | [%n%]$;$    | ^repeat^ $last find$ %n times% in line                                 | <
  | [%n%]$,$    | ^repeat^ $last find$ %n times% in line in %opposite direction%           | <

# Move > Cursor and Window

  • $Cursor$ position vs $Window$ position <
  • Vim always make sure cursor is %inside% window <
  • The window position depends on $scrolloff$ config <

# Move > Move by line

  • Use $gg$ or $G$ to move to line <

  | Command | Description                   | <
  | ------- | ----------------------------- |
  | $gg$      | ^move^ $cursor$ to the %first line% | <
  | $G$       | ^move^ $cursor$ to the %last line%  | <
  | [%n%]$gg$   | ^move^ $cursor$ to $line$ %n%         | <
  | [%n%]$G$    | ^move^ $cursor$ to $line$ %n%         | <
  | $:{n}$    | ^move^ $cursor$ to $line$ %n%         | <

# Move > Move by page

  • Move faster by $page$ <
  • More useful to $navigate$ rather than position <
  • Harder to interpret the exact position <

  | Command  | Description                                                  | <
  | -------- | ------------------------------------------------------------ |
  | $<C-d>$    | ^move^ $cursor$ %half page down%                                   | <
  | $<C-u>$    | ^move^ $cursor$ %half page up%                                     | <
  | $<C-f>$    | ^scroll^ $window$ %one page down%                                  | <
  | $<C-b>$    | ^scroll^ $window$ %one page up%                                    | <
  | $H$        | ^move^ $cursor$ to the %"top"% of $window$                           | <
  | $M$        | ^move^ $cursor$ to the %middle% of $window$                          | <
  | $L$        | ^move^ $cursor$ to the %"bottom"% of $window$                        | <
  | $zt$,$z<CR>$ | ^scroll^ $window$ to make current line to the %"top"% of $window$    | <
  | $zz$,$z.$    | ^scroll^ $window$ to make current line to the %"middle"% of $window$ | <
  | $zb$,$z-$    | ^scroll^ $window$ to make current line to the %"bottom"% of $window$ | <

# Move > Move by object

  • Move by $sentence$ and $paragraph$ <

  | Command | Description                                 | <
  | ------- | ------------------------------------------- |
  | [%n%]$($    | ^move^ to the %beginning% of %previous% $sentence$  | <
  | [%n%]$)$    | ^move^ to the %beginning% of %next% $sentence$      | <
  | [%n%]${$    | ^move^ to the %beginning% of %previous% $paragraph$ | <
  | [%n%]$}$    | ^move^ to the %beginning% of %next% $paragraph$     | <

# Move > Move by search

  • We can also use pattern $search$ to move around <
  • More in $Search$ section <

  | Command        | Description                           | <
  | -------------- | ------------------------------------- |
  | [%n%]$*$           | ^search^ %forward% for $word under cursor$  | <
  | [%n%]$#$           | ^search^ %backward% for $word under cursor$ | <
  | $/${pattern}$<CR>$ | ^search^ %forward% for ${pattern}$          | <
  | $?${pattern}$<CR>$ | ^search^ %backward% for pattern ${pattern}$ | <
  | [%n%]$n$           | ^move^ to the %next% $match$                | <
  | [%n%]$N$           | ^move^ to the %previous% $match$            | <

# Move > Move by match

  • We can also move around using $([{$ semantics <

  | Command | Description                                                | <
  | ------- | ---------------------------------------------------------- |
  | $%$       | ^find^ $([{ in line$ and ^move^ to the $matching close$            | <
  | $[{$      | ^go^ to %previous% $unmatched {$ (%beginning% of $outer code block$) | <
  | $]}$      | ^go^ to %next% $unmatched }$ (%end% of $outer code block$)           | <
  | $[($      | ^go^ to %previous% $unmatched ($ (%beginning% of $outer func param$) | <
  | $])$      | ^go^ to %next% $unmatched )$ (%end% of $outer func param$)           | <

# Move > Move by mark

  • Mark is useful for $remember$ a location <
  • Take advantage of $special marks$ <

  | Command | Description                             | <
  | ------- | --------------------------------------- |
  | $m${mark} | ^add^ a $mark$                              | <
  | $`${mark} | ^goto^ a $mark$ (%exact position%)            | <
  | $'${mark} | ^goto^ a $mark$ (%first non-blank character%) | <
  | $:marks$  | ^list^ $marks$                              | <

  | Marks | Description                              | <
  | ----- | ---------------------------------------- |
  | ${a-z}$ | $local$ mark in buffer                     | <
  | ${A-Z}$ | $global$ mark                              | <
  | $.$     | $last edited$                              | <
  | $'$     | $latest jump$                              | <
  | $`$     | $latest jump$                              | <
  | $"$     | $last position$ before leave buffer        | <
  | $^$     | $last insert$ position                     | <
  | $[$     | %beginning% of $last changed or yanked$ text | <
  | $]$     | %end% of $last changed or yanked$ text       | <
  | $<$     | %beginning% of $last visual select$          | <
  | $>$     | %end% of $last visual select$                | <

# Move > Move by jumps

  • $jumplist$ maintains jumps history, we can use it to jump back and forth <

  | Command  | Description                        | <
  | -------- | ---------------------------------- |
  | [%n%]$<C-o>$ | ^jump^ to %older% position in $jumplist$ | <
  | [%n%]$<C-i>$ | ^jump^ to %newer% position in $jumplist$ | <
  | $:jumps$   | ^list^ $jumps history$                 | <

# Move > Move by changes

  • $changelist$ maintains changes history, we can use it to jump back and forth as well <

  | Command  | Description                          | <
  | -------- | ------------------------------------ |
  | [%n%]$g;$    | ^jump^ to %older% position in $changelist$ | <
  | [%n%]$g,$    | ^jump^ to %newer% position in $changelist$ | <
  | $gi$       | ^insert^ at $last insert position$       | <
  | $:changes$ | ^list^ $changes history$                 | <

# Edit > Edit in Normal mode

  • Basic commands to edit text in $Normal$ mode <

  | Command        | Description                        | <
  | -------------- | ---------------------------------- |
  | [%n%]$x$           | ^delete^ $current character$           | <
  | [%n%]$r${c}        | ^replace^ $current character$ with %{c}% | <
  | [%n%]$dd$          | ^delete^ $current line$                | <
  | [%n%]$D$           | ^delete^ to $end of current line$      | <
  | [%n%]$d${%motion%}   | ^delete^ using %motion%                | <
  | [%n%]$J$           | ^join^ $lines$                         | <

# Edit > Enter Insert mode

  • There are various ways to ^enter^ $Insert$ mode <
  • Many of them have additional move benefits. <

  | Command | Description                             | <
  | ------- | --------------------------------------- |
  | $a$       | ^append^ %after% $cursor$                     | <
  | $A$       | ^append^ %after% $end of line$                | <
  | $i$       | ^insert^ %before% $cursor$                    | <
  | $I$       | ^insert^ %before% $first non-blank character$ | <
  | $o$       | ^insert^ %below% $line$                       | <
  | $O$       | ^insert^ %above% $line$                       | <
  | $s$       | ^change^ %current% $character$                | <
  | $C$       | ^change^ %until% $end of line$                | <
  | $cc$      | ^change^ %current% $line$                     | <

# Edit > Edit in Insert mode

  • There are various ways to ^edit^ in $Insert$ mode <

  | Command        | Description                                  | <
  | -------------- | -------------------------------------------- |
  | $typing$         | ^typing^ to edit                               | <
  | $<BS>$           | ^delete^ %left%                                  | <
  | $<DEL>$          | ^delete^ %right%                                 | <
  | $<C-w>$          | ^delete^ %left% $a word$                           | <
  | $<C-u>$          | ^delete^ %left to% $first non-blank word$          | <
  | $<C-r>${reg}     | ^insert^ $register {reg}$                        | <
  | $<C-r>=$         | ^insert^ $eval result of an expression$          | <
  | $<C-v>${c}       | ^insert^ ${c}$ %literally%                         | <
  | $<C-k>${digraph} | ^insert^ ${digraph}$                             | <
  | $<C-o>$          | ^run^ $a Normal command$ and ^back^ to $Insert$ mode | <

# Edit > Count + Operator + Motion

  $Count$ + ^Operator^ + %Motion% <
  • $Count$: an arbitrary number (_how many_) <
  • ^Operator^: an action (_what_) <
  • %Motion%: a descriptive (_how_) <

# Edit > Operator

  • ^Operator^: an action (_what to do_) <

  | Command | Description  | <
  | ------- | ------------ |
  | $c$       | ^change^       | <
  | $d$       | ^delete^       | <
  | $y$       | ^yank^         | <
  | $=$       | ^auto indent^  | <
  | $>$       | ^indent^ %right% | <
  | $<$       | ^indent^ %left%  | <
  | $~$,$g~$    | ^swap case^    | <
  | $gu$      | ^lower case^   | <
  | $gU$      | ^upper case^   | <

# Edit > Motion

  • %Motion%: a descriptive (_how_) <
    ▸ $All move commands$ mentioned before (_almost_) <
    ▸ $Text Object$ <

# Edit > Text Object

  • $Selection Mode$ <
    ▸ $i$: %inside% (exclusive) <
    ▸ $a$: %around% (inclusive) <

  • $Text Objects$ <

    | Command | Description    | <
    | ------- | -------------- |
    | $w$       | $word$           | <
    | $W$       | $WORD$           | <
    | $s$       | $sentence$       | <
    | $p$       | $paragraph$      | <
    | $t$       | $xml tag$        | <
    | $'$       | $single quotes$  | <
    | $"$       | $double quotes$  | <
    | $`$       | $backticks$      | <
    | $[$,$]$     | $brackets$       | <
    | $($,$)$,$b$   | $parentheses$    | <
    | ${$,$}$,$B$   | $braces$         | <
    | $<$,$>$     | $angle brackets$ | <

  • $Custom Text Objects$ <

# Edit > Count + Operator + Motion

  $Count$ + ^Operator^ + %Motion% <

  • It is an atomic action and can be repeated using $.$ command <
  • Let's see some examples <

  | Command | Description             | <
  | ------- | ----------------------- |
  | $dw$      | ^delete^ %by% $word$          | <
  | $diw$     | ^delete^ %inside% $word$      | <
  | $dap$     | ^delete^ %around% $paragraph$ | <
  | $cib$     | ^change^ %inside% $()$        | <
  | $cit$     | ^change^ %inside% $tag$       | <
  | $ct,$     | ^change^ %until% $,$          | <
  | $diB$     | ^delete^ %inside% ${}$        | <

# Edit > Registers

  • Registers are the enhanced "clipboards" in Vim <

  | Register | Description               | <
  | -------- | ------------------------- |
  | $"$        | %unnamed% (any last change) | <
  | $0$        | %yank%                      | <
  | $1$-$9$      | %delete% (1 is the newest)  | <
  | ${a-z}$    | %named% $register$ (replace)  | <
  | ${A-Z}$    | %named% $register$ (append)   | <
  | $%$        | %current file%              | <
  | $#$        | %alternative file%          | <
  | $:$        | %last ex command%           | <
  | $/$        | %last search%               | <
  | $+$        | %system clipboard%          | <
  | $*$        | %primary clipboard%         | <
  | $.$        | %last inserted text%        | <
  | $=$        | %expression%                | <
  | $-$        | %small change% (in a line)  | <

# Edit > Registers

  • How to use registers <

  | Command         | Description                                         | <
  | --------------- | --------------------------------------------------- |
  | $"${reg}$y${%motion%} | ^set^ $register {reg}$                                  | <
  | $"${reg}$p$         | ^put^ $register {reg}$                                  | <
  | $:reg$isters      | ^show^ $registers$                                      | <
  | $<C-r>${reg}      | ^insert^ $register {reg}$ (in $Insert$/$Command-line$ mode) | <
  | $@${reg}          | ^insert^ $register {reg}$ in eval mode                  | <

# Edit > Yank & Put

  • Yank is "Copy" in Vim <
  • Put is "Paste" in Vim <

  | Command           | Description               | <
  | ----------------- | ------------------------- |
  | [%n%]$yy$             | ^yank^ $line(s)$              | <
  | [%n%]$Y$              | ^yank^ $line(s)$              | <
  | [$"{reg}$]$y${%motion%} | ^yank^ to $register {reg}$    | <
  | [$"{reg}$]$p$         | ^put^ $register {reg}$ %after%  | <
  | [$"{reg}$]$P$         | ^put^ $register {reg}$ %before% | <

# Edit > Yank & Put use cases

  • $xp$ <
    => ^swap^ $character$ <

  • $ddp$ <
    => ^swap^ $line$ <

  • $yyp$ <
    => ^duplicate^ $line$ <

  • swap two adjacent words? <
    => $dwwhp$ <
    => $dww^P^$ <
    => $d^e^wP^ldebh^P$ <
    => $de^mm^wPlde^`m^P$ <
    => $d^iw^mmwPlde`mP$ <

# Edit > Undo & Redo

  • Undo and Redo (revert undo) is common, but Vim gives us a more sophisticated one. <

  | Command  | Description                       | <
  | -------- | --------------------------------- |
  | [%n%]$u$     | ^undo^ $change(s)$                    | <
  | [%n%]$<C-r>$ | ^redo^ $changes(s)$                   | <
  | $U$        | ^undo^ $all latest changes in a line$ | <

# Edit > Undo Branchs

  • Undos can $branch$ off <
  • We can undo by time sequence <

  | Command               | Description                                 | <
  | --------------------- | ------------------------------------------- |
  | $:undol$ist             | ^show^ $undo list$                              | <
  | [%n%]$g-$                 | ^go to^ %older% $state$                           | <
  | [%n%]$g+$                 | ^go to^ %newer% $state$                           | <
  | $:ea$rlier {%n%}          | ^go to^ %older% $state$                           | <
  | $:ea$rlier {%n%}%s/m/h/d/f% | ^go to^ %older% $state$ about certain time %before% | <
  | $:lat$er {%n%}            | ^go to^ %newer% $state$                           | <
  | $:lat$er {%n%}%s/m/h/d/f%   | ^go to^ %newer% $state$ about certain time %after%  | <

# Command-line > Ex Command

  • Use $:$ to initiate the command and $<CR>$ to execute <

  | Command      | Description   | <
  | ------------ | ------------- |
  | $:$%{cmd}%       | ^enter^ $command$ | <
  | $:e$dit {file} | ^edit^ $file$     | <
  | $:w$rite       | ^write^ to $file$ | <
  | $:so$urce      | ^source^ $script$ | <

# Command-line > Ex Command History

  • Quickly access to command history <

  | Command      | Description                                       | <
  | ------------ | ------------------------------------------------- |
  | $:$%{cmd}%$<UP>$   | ^complete^ %previous matched% $command$ on $prefix$       | <
  | $:$%{cmd}%$<DOWN>$ | ^complete^ %next matched% $command$ on $prefix$           | <
  | $:$%{cmd}%$<C-p>$  | ^complete^ %previous% $command$                         | <
  | $:$%{cmd}%$<C-n>$  | ^complete^ %next% $command$                             | <
  | $q:$           | ^show^ $command-line window$                          | <
  | $<C-f>$        | ^show^ $command-line window$ (from command-line mode) | <

# Command-line > Ex Command for editing

  • Ex commands for editing <

  | Command                             | Description                          | <
  | ----------------------------------- | ------------------------------------ |
  | $:$[%range%]$d$elete [$reg$]                | ^delete^ %range% to $reg$                  | <
  | $:$[%range%]$y$ank [$reg$]                  | ^yank^ %range% to $reg$                    | <
  | $:$[%line%]$pu$t [$reg$]                    | ^put^ $reg$ after %line%                   | <
  | $:$[%range%]$co$py {$line$}                 | ^copy^ %range% after $line$                | <
  | $:$[%range%]$t$ {$line$}                    | ^copy^ %range% after $line$                | <
  | $:$[%range%]$m$ove {$line$}                 | ^move^ %range% after $line$                | <
  | $:$[%range%]$j$oin                        | ^join^ $lines$ in %range%                  | <
  | $:norm$al[%!%] {$cmd$}                    | ^run^ normal command                   | <
  | $:$[%range%]$s$ubstitute/$pattern$/new/[gc] | ^substitute^ in %range% matching $pattern$ | <
  | $:$[%range%]$g$lobal/$pattern$/[$cmd$]        | ^run^ $cmd$ in %range% matching $pattern$    | <

# Command-line > Ex Command range

  • What is a $range$ ? <

  | Command          | Description           | <
  | ---------------- | --------------------- |
  | $:%n%$               | $line$ %n%                | <
  | $:+%n%$              | the %next nth% $line$     | <
  | $:-%n%$              | the %previous nth% $line$ | <
  | $:.$               | %current% $line$          | <
  | $:0$               | %first% $line$            | <
  | $:$$               | %last% $line$             | <
  | $:%$               | %all% $lines$             | <
  | $:/{pattern}/${%+1%} | %matched% $line$          | <
  | $:${%start%}$,${%end%}   | from %start% to %end%     | <

# Command-line > Ex Command shell

  • Running shell in Vim is handy <

  | Command         | Description                        | <
  | --------------- | ---------------------------------- |
  | $:!${$cmd$}         | ^run^ $shell cmd$                      | <
  | $:!python %$      | ^run^ $python$ with current file       | <
  | $:$[%range%]$r!${$cmd$} | ^run^ $cmd$ and insert output to %range% | <

# Visual > Enter Visual mode

  • There are three ways to enter slightly different $Visual$ mode <

  | Command | Description                      | <
  | ------- | -------------------------------- |
  | $v$       | ^switch to^ %normal% $Visual$ mode     | <
  | $V$       | ^switch to^ %line-wise% $Visual$ mode  | <
  | $<C-v>$   | ^switch to^ %block-wise% $Visual$ mode | <

  • These commands can be used to ^switch^ between different modes as well <

  • We can ^reselect^ the $last visual selection$ using $gv$ <

# Visual > Visual mode selection

  • How can we select in $Visual$ mode? <

  | Command  | Description                              | <
  | -------- | ---------------------------------------- |
  | ${motion}$ | ^change^ %current end% of $visual selection$   | <
  | $o$        | ^select^ the %other end% of $visual selection$ | <

# Visual > More Visual mode

  • What we can do in $Visual$ mode? <

  | Command | Description     | <
  | ------- | --------------- |
  | $d$       | ^delete^ selected | <
  | $y$       | ^yank^ selected   | <
  | $c$       | ^change^ selected | <
  | $I$       | ^insert^ %before%   | <
  | $A$       | ^append^ %after%    | <

  • $^Operator^ + %Motions%$ is typically favorable over $Visual selection$ <

# Repeat > The . Command

  • $.$ can ^repeat^ last change <
  • $.$ can use $count$ <
  • $.$ does %not% repeat command-line command <
  • Idealy a change should be $Count$ + ^Operator^ + %Motion% <

# Repeat > The . Command example

  • delete word in sentence: This is no$t$ a test <
    => $dbxx$ <
    => $bdw$ <
    => $daw$ <

# Repeat > Macro

  • Macro records all keystrokes in register and replay <

  | Command    | Description            | <
  | ---------- | ---------------------- |
  | $q${$reg$}     | ^start^ record to $reg$    | <
  | $q$          | ^stop^ record            | <
  | $:reg$isters | ^show^ $registers$         | <
  | [%n%]$@${$reg$}  | ^replay^ macro in $reg$    | <
  | [%n%]$@@$      | ^replay^ %previous% macro  | <
  | [%n%]$@:$      | ^replay^ %last% $Ex command$ | <

# Repeat > Code Clinic

  • Append ; to all lines? <
    => $$$$a;$ + $.$ <
    => $A;$ + $.$ <
    => $qaA;<ESC>j$ + $[n]@a$ <
    => $$$$<C-v>[n]jA;$ <

# Search > Search in buffer

  • Recap <

  | Command        | Description                           | <
  | -------------- | ------------------------------------- |
  | [%n%]$*$           | ^search^ %forward% for $word under cursor$  | <
  | [%n%]$#$           | ^search^ %backward% for $word under cursor$ | <
  | $/${pattern}$<CR>$ | ^search^ %forward% for ${pattern}$          | <
  | $?${pattern}$<CR>$ | ^search^ %backward% for pattern ${pattern}$ | <
  | [%n%]$n$           | ^move^ to the %next% $match$                | <
  | [%n%]$N$           | ^move^ to the %previous% $match$            | <

# Search > Search in buffer

  • More search <

  | Command        | Description                                            | <
  | -------------- | ------------------------------------------------------ |
  | $g*$             | ^search^ %forward% for $word under cursor$ without boundary  | <
  | $g#$             | ^search^ %backward% for $word under cursor$ without boundary | <
  | $/<CR>$          | ^repeat^ %last% $search$ (pattern only)                      | <
  | $gn$             | ^repeat^ %last% $search$ %forward% and ^select^ $match$ in visual  | <
  | $gN$             | ^repeat^ %last% $search$ %backward% and ^select^ $match$ in visual | <
  | $:noh$lsearch    | ^hide^ $highlight$ once                                    | <
  | $:set incsearch$ | ^show^ $highlight$ when typing                             | <
  | $q/$             | ^show^ $search history$                                    | <

# Search > Search mode

  • $magic$ (default) <
  • $very magic$ (matching character without backslash) <
  • $very nomagic$ (matching character literally) <

  | Command | Description       | <
  | ------- | ----------------- |
  | $\v$      | very magic mode   | <
  | $\V$      | very nomagic mode | <

# Search > Search mode example

  • $#AA0BB1 or #AA0$ <
    => /#\([0-9a-fA-F]\{6}\|[0-9a-fA-F]\{3}\) <
    => /\v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3}) <
    => /\v#(\x{6}|\x{3}) <

  • $a.k.a.$ but not $backward$ <
    => /a\.k\.a\. <
    => /\Va.k.a. <

# Search > Offset

  • We can add offset to search option <
  • $/${pattern}/{%offset%}$<CR>$ <

  | Option             | Description                                  | <
  | ------------------ | -------------------------------------------- |
  | ${n}$, $+{n}$, $-{n}$    | ^offset^ by $line$ (watch out for infinite loop) | <
  | $b{n}$, $b+{n}$, $b-{n}$ | ^offset^ relative to the %beginning% of $match$    | <
  | $s{n}$, $s+{n}$, $s-{n}$ | ^offset^ relative to the %start% of $match$        | <
  | $e{n}$, $e+{n}$, $e-{n}$ | ^offset^ relative to the %end% of $match$          | <
  | $;$                  | ^offset^ by $another search$                     | <

# Search > Case match

  • Config level case match <
  • Match level case match override <

  | Option     | Description                                  | <
  | ---------- | -------------------------------------------- |
  | $ignorecase$ | ^ignore^ case                                  | <
  | $smartcase$  | ^use^ %smart% case                               | <
  | $\c$         | ^ignore^ case (override ignorecase, smartcase) | <
  | $\C$         | ^match^ case (override ignorecase, smartcase)  | <

# Search > Match boundary

  • Sometimes we want to match the whole pattern but only interested in part of it <

  | Option | Description        | <
  | ------ | ------------------ |
  | $\zs$    | ^set^ %start% of $match$ | <
  | $\ze$    | ^set^ %end% of $match$   | <

  • $match string content only$ <
    => /\v"\zs[^"]*\ze" <

# Search > Multiple lines

  • Sometimes we do want to match multiple lines <

  | Option | Description               | <
  | ------ | ------------------------- |
  | $\_${c}  | pattern {c} + %end% of $line$ | <

  • $match multi-line string$ <
    => /\v"\_[^"]*" <

# Search > Capture match

  • Sometimes we want capture the match to use it for further purpose <

  | Option | Description               | <
  | ------ | ------------------------- |
  | $()$     | ^capture^ match group       | <
  | $%()$    | ^avoid capture^ match group | <

  • $match any repeated words$ <
    ▸ test test <
    => /test test <
    ▸ test   test <
    => /%\v%test%\s+%test <
    ▸ multiline <
    => /\vtest(%\n%|\s)+test <
    => /\vtest%\_s%+test <
    ▸ atest testb <
    => /\v%<%test\_s+test%>% <
    ▸ test2 test2 <
    => /\v<%(\w+)%\_s+%\1%> <
    ▸ test test test <
    => /\v<(\w+)%(%\_s+\1>%)+% <

# Search > Substitute

  • On top of search, we can do substitute <

  | Command                         | Description                                       | <
  | ------------------------------- | ------------------------------------------------- |
  | $:$[%range%]$s$ubstitute/old/new/[%gc%] | ^substitute^ in $buffer$                                | <
  | $:s$,$:&$,$&$                         | ^repeat^ last $substitute$ %without% options            | <
  | $:&&$                             | ^repeat^ last $substitute$ %with% options               | <
  | $g&$                              | ^repeat^ last $substitute$ %with% options for $all lines$ | <
  | $:$[%range%]$s$ubstitute//new/[%gc%]    | ^substitute^ reusing $last search pattern$            | <

# Search > Global

  • On top of search, we can do global command <
  • Select lines match with pattern (or negate) and run Ex command <

  | Command                       | Description                           | <
  | ----------------------------- | ------------------------------------- |
  | $:$[%range%]$g$lobal/pattern/[%cmd%]  | ^run^ $cmd$ in %range% matching $pattern$     | <
  | $:$[%range%]$v$lobal/pattern/[%cmd%]  | ^run^ $cmd$ in %range% %NOT% matching $pattern$ | <
  | $:$[%range%]$g!$lobal/pattern/[%cmd%] | ^run^ $cmd$ in %range% %NOT% matching $pattern$ | <

  • %range% by default is $%$
  • %cmd% by default is $p$

  • :g/bad <
    => print all lines contain $bad$ <

  • :g/bad/d <
    => delete all lines contain $bad$ <

  • :g!/good/d <
    => keep all lines contain $good$ <

  • :g/{/.+1,/}/-1sort <
    => sort lines inside matching braces <
    => {{{txt$:g/\v\{$\n\zs\_[^{]{-,}\ze^\s*\}/.+1,/}/-1sort}}}

# Files > File

  | Command        | Description                                   | <
  | -------------- | --------------------------------------------- |
  | $:e$dit {%file%}   | ^edit^ $file$ in window                           | <
  | $:e$dit$!$         | ^read^ $file$ from disk (discard unsaved changes) | <
  | $:w$rite[$!$]      | ^write^ to $file$ (override if using $!$)           | <
  | $:wa$ll[$!$]       | ^write^ all to $file$ (override if using $!$)       | <
  | $:sp$lit {%file%}  | ^edit^ $file$ in %horizontal% split                 | <
  | $:vs$plit {%file%} | ^edit^ $file$ in %vertical% split                   | <

# Files > Window

  | Command               | Description                             | <
  | --------------------- | --------------------------------------- |
  | $<C-w>s$                | ^split^ $window$ %horizontally%               | <
  | $<C-w>v$                | ^split^ $window$ %vertically%                 | <
  | $<C-w>${$h$,$j$,$k$,$l$}        | ^move^ to %left%, %bottom%, %top%, %right% $window$ | <
  | $<C-w>w$                | ^move^ to %next% $window$ (cycle)             | <
  | $<C-w>c$, $:clo$se        | ^close^ %current% $window$                    | <
  | $<C-w>o$, $:on$ly         | ^close^ %all other% $windows$                 | <
  | $<C-w>$[%count%]{$+$,$-$,$<$,$>$} | ^expand/shrink^ %current% $window$            | <

# Files > Tab

  | Command                 | Description                            | <
  | ----------------------- | -------------------------------------- |
  | $:tabe$dit {%file%}         | ^edit^ $file$ in new $tab$                   | <
  | $:tabn$ext [$id$] or [$id$]$gt$ | ^move^ to %next% $tab$ or $id$                 | <
  | $:tabp$revious or $gT$      | ^move^ to %previous% $tab$                   | <
  | $:tabc$lose               | ^close^ %current% $tab$                      | <
  | $:tabo$nly                | ^close^ %all other% $tabs$                   | <
  | $:tabm$ove [$id$]           | ^move^ $tab$ to $id$ (or to the end if omit) | <
  | $<C-w>T$                  | ^move^ %current% $window$ to a $tab$           | <

# Files > File vs Buffer vs Window vs Tab

  ## For most editors
  • File = [Buffer] = [Window] = [Tab]

  ## For Vim
  • $File$ is contents in %disk% (not a focus in Vim) <
  • $Buffer$ is contents in %memory% (used a lot in Vim) <
  • $Window$ is a %viewport%, or a %container% for a $Buffer$
  • $Tab$ is a %group% of $Windows$

# Files > Buffer List

  • Buffer list maintains a list of opened buffers <
  • Tends to be changed easily <

  | Command         | Description                              | <
  | --------------- | ---------------------------------------- |
  | $:ls$, $:buffers$   | ^list^ all $buffers$                         | <
  | $:bn$ext [%n%]      | ^goto^ %n%th %next% $buffer$ in buffer list      | <
  | $:bp$revious [%n%]  | ^goto^ %n%th %previous% $buffer$ in buffer list  | <
  | $:bf$irst         | ^goto^ %first% $buffer$ in buffer list         | <
  | $:bl$alst         | ^goto^ %last% $buffer$ in buffer list          | <
  | $:b$uffer{$id$}     | ^goto^ $buffer$ %id% in buffer list            | <
  | $:bd$elete {$ids$}  | ^delete^ $buffers$ of %ids% in buffer list     | <
  | $:$[%range%]$bd$elete | ^delete^ $buffers$ with %range% in buffer list | <

  | Indicator | Description          | <
  | --------- | -------------------- |
  | $%$         | active window buffer | <
  | $#$         | alternative buffer   | <
  | $a$         | visible buffer       | <
  | $h$         | hidden buffer        | <
  | $+$         | modified buffer      | <

# Files > Argument List

  • Originated from starting Vim with multiple files <
  • More stable and well defined <
  • Normally a subset of buffer list <

  | Command           | Description                               | <
  | ----------------- | ----------------------------------------- |
  | $vim$ {$pattern$}     | ^open^ Vim with argument list using $pattern$ | <
  | $:ar$gs             | ^list^ argument list                        | <
  | $:ar$gs {$pattern$}   | ^recreate^ argument list using $pattern$      | <
  | $:$[%n%]$arga$dd [$file$] | ^add^ $file$ to argument list after %nth%       | <
  | $:$[%n%]$n$ext          | ^goto^ %nth next% buffer in argument list     | <
  | $:$[%n%]$prev$ious      | ^goto^ %nth previous% buffer in argument list | <
  | $:fir$st            | ^goto^ %first% in argument list               | <
  | $:la$st             | ^goto^ %last% in argument list                | <

# Files > Quickfix List

  • Quickfix list is designed for navigating across different positions <
  • Only $one$ global quickfix list <

  | Command                   | Description                                         | <
  | ------------------------- | --------------------------------------------------- |
  | $:vim$grep {$pattern$} {$file$} | ^search^ for $pattern$ in $file$ and ^add^ to quickfix list | <
  | $:cope$n                    | ^open^ quickfix list                                  | <
  | $:ccl$ose                   | ^close^ quickfix list                                 | <
  | $:$[%n%]$cn$ext                 | ^goto^ %nth next% $entry$ in quickfix list                | <
  | $:$[%n%]$cp$revious             | ^goto^ %nth previous% $entry$ in quickfix list            | <
  | $:$[%n%]$cnf$ile                | ^goto^ %nth next% $file$ in quickfix list                 | <
  | $:$[%n%]$cpf$ile                | ^goto^ %nth previous% $file$ in quickfix list             | <
  | $:cfir$st                   | ^goto^ %first% $entry$ in quickfix list                   | <
  | $:cla$st                    | ^goto^ %last% $entry$ in quickfix list                    | <

# Files > Location List

  • Location list is a variation of Quickfix List <
  • Each window has one separate location list <

  | Command                    | Description                                         | <
  | -------------------------- | --------------------------------------------------- |
  | $:lvim$grep {$pattern$} {$file$} | ^search^ for $pattern$ in $file$ and ^add^ to location list | <
  | $:lop$en                     | ^open^ location list                                  | <
  | $:lcl$ose                    | ^close^ location list                                 | <
  | $:$[%n%]$lne$xt                  | ^goto^ %nth next% $entry$ in location list                | <
  | $:$[%n%]$lp$revious              | ^goto^ %nth previous% $entry$ in location list            | <
  | $:$[%n%]$lnf$ile                 | ^goto^ %nth next% $file$ in location list                 | <
  | $:$[%n%]$lpf$ile                 | ^goto^ %nth previous% $file$ in location list             | <
  | $:lfir$st                    | ^goto^ %first% $entry$ in location list                   | <
  | $:lla$st                     | ^goto^ %last% $entry$ in location list                    | <

# Files > Rum command across collections

  • We know how to run command in file <
  • How can we run command in a collection of files? <

  | Command             | Description                                  | <
  | ------------------- | -------------------------------------------- |
  | $:$[%range%]$bufdo$ {$cmd$} | ^run^ $cmd$ on %range% in $buffer list$              | <
  | $:$[%range%]$argdo$ {$cmd$} | ^run^ $cmd$ on %range% in $argument list$            | <
  | $:cdo$ {$cmd$}          | ^run^ $cmd$ on each $entry$ in $quickfix list$       | <
  | $:cfdo$ {$cmd$}         | ^run^ $cmd$ on each $file$ in $quickfix list$        | <
  | $:ldo$ {$cmd$}          | ^run^ $cmd$ on each $entry$ in $location list$       | <
  | $:lfdo$ {$cmd$}         | ^run^ $cmd$ on each $file$ in $location list$        | <
  | $:$[%range%]$windo$ {$cmd$} | ^run^ $cmd$ on %range% in $each window$              | <
  | $:$[%range%]$tabdo$ {$cmd$} | ^run^ $cmd$ on %range% in $each tab$ (active window) | <

# Misc > Spell Checking

  • Vim has built-in support for spell checking which can be useful <

  | Command        | Description                              | <
  | -------------- | ---------------------------------------- |
  | $set spell$      | ^enable^ spell checking for current $window$ | <
  | $setlocal spell$ | ^enable^ spell checking for current $buffer$ | <
  | $z=$             | ^show^ suggested words                     | <
  | $zg$             | ^add^ current word as %good% word            | <
  | $zw$             | ^add^ current word as %wrong% word           | <

# Misc > Folding

  • Folding can be useful for visual <
  • There're different folding strategies: manual, indent, expr, syntax, diff, marker <
  • $expr$ is more useful and flexible in general <

  | Command | Description                        | <
  | ------- | ---------------------------------- |
  | $zi$      | ^enable/disable^ folding             | <
  | $za$      | ^toggle^ current fold                | <
  | $zR$      | ^open^ all folds                     | <
  | $zM$      | ^close^ all folds                    | <
  | $zC$      | ^close^ current fold %recursively%     | <
  | $zv$      | ^open^ minimal folds to show cursor  | <
  | $zj$      | ^move^ %down% to top of next fold      | <
  | $zk$      | ^move^ %up% to bottom of previous fold | <

# Misc > Miscellaneous command

  | Command  | Description                          | <
  | -------- | ------------------------------------ |
  | [%n%]$<C-a>$ | ^add^ %n% to $number at/after cursor$      | <
  | [%n%]$<C-x>$ | ^subtract^ %n% to $number at/after cursor$ | <

# Config > Base

  • Configurability is the core of Vim. <

  | Option                    | Description                            | <
  | ------------------------- | -------------------------------------- |
  | $syntax on$                 | ^enable^ $syntax highlighting$             | <
  | $filetype plugin indent on$ | ^enable^ $filetype with plugin and indent$ | <
  | ^set^ $nocompatible$          | ^disable^ $compatible$ mode                | <

# Config > Line Numbers

  • A combination of %absolute% and %relative% line number <

  | Config             | Description          | <
  | ------------------ | -------------------- |
  | ^set^ $number$         | ^show^ $line number$     | <
  | ^set^ $relativenumber$ | ^show^ $relative number$ | <

# Config > Cursor

  • Show current cursor position <

  | Config           | Description        | <
  | ---------------- | ------------------ |
  | ^set^ $cursorline$   | ^show^ $cursor line$   | <
  | ^set^ $cursorcolumn$ | ^show^ $cursor column$ | <

# Config > Whitespace

  | Config                        | Description                                | <
  | ----------------------------- | ------------------------------------------ |
  | ^set^ $list$                      | show whitespaces                           |
  | ^set^ $listchars=%tab:▸\ ,trail:•%$ | config characters to shown for whitespaces |

# Config > Tab vs Space

  | Config            | Description                                    | <
  | ----------------- | ---------------------------------------------- |
  | ^set^ $expandtab$     | spaces instead of tab                          | <
  | ^set^ $tabstop=%2%$     | number of spaces a tab counts for              | <
  | ^set^ $softtabstop=%2%$ | number of spaces a tab counts for when editing | <
  | ^set^ $shiftwidth=%2%$  | number of spaces for indent                    | <

# Config > Command-line Completion

  | Config                         | Description                    | <
  | ------------------------------ | ------------------------------ |
  | ^set^ $wildmenu$                   | enable command-line completion | <
  | ^set^ $wildmode=%list:longest,full%$ | completion mode                | <

# Config > Search

  | Config         | Description                                           | <
  | -------------- | ----------------------------------------------------- |
  | ^set^ $ignorecase$ | ignore case in search                                 |
  | ^set^ $smartcase$  | match case if search pattern contains upper case char |
  | ^set^ $hlsearch$   | highlight search matches                              |
  | ^set^ $incsearch$  | highlight search matches when typing                  |

# Config > Format

  | Config               | Description                          | <
  | -------------------- | ------------------------------------ |
  | ^set^ $autoindent$       | copy indent when starting a new line | <
  | ^set^ $textwidth=%120%$    | max width of text when editing       | <
  | ^set^ $colorcolumn=%+1%$   | highlight column after 'textwidth'   | <
  | ^set^ $formatoptions%-=t%$ | config automatic formatting          | <

# Config > Undo

  | Config                  | Description               | <
  | ----------------------- | ------------------------- |
  | ^set^ $undofile$            | save undo history in file |
  | ^set^ $undodir=%~/.vim/undo%$ | undo file location        |
  | ^set^ $undolevels=%1000%$     | undo level                |

# Config > Misc

  | Config                             | Description                                   | <
  | ---------------------------------- | --------------------------------------------- |
  | ^set^ $directory=%~/.vim/swap%$          | swap file location                            | <
  | ^set^ $foldlevelstart=%99%$              | fold closed by default                        | <
  | ^set^ $pastetoggle=%<F1>%$               | paste mode mapping                            | <
  | ^set^ $scrolloff=%3%$                    | cursor off edge                               | <
  | ^set^ $showmatch$                      | move to matching ({[ briefly when close match |
  | ^set^ $viewoptions=%folds,cursor%$       | save folds and cursor for view                | <
  | ^set^ $viminfo=%'100,/100,h,\"500,:500%$ | save & restore when Vim restart               |

# Config > Abbreviation

  | Config                         | Description  | <
  | ------------------------------ | ------------ |
  | ^ia^bbrev $bw baptiste, wstrasser$ | abbreviation |
  | ^ia^bbrev $tihs this$              | abbreviation |

# Config > Colorscheme

  | Config                          | Description          | <
  | ------------------------------- | -------------------- |
  | ^colo^rscheme ${colorscheme}$       | use colorscheme      |
  | ^hi^ghlight ${group} {key}={val}$   | set highlight group  |
  | ^hi^ghlight $link {group} {target}$ | link highlight group |

# Config > Key Mapping

  • Key mapping is one of Vim's real power. <
  • $<Leader>$ is a special key prefix. <

  | Config                        | Description                      | <
  | ----------------------------- | -------------------------------- |
  | ^map^ ${keys} {target}$           | map for %any% mode                 |
  | ^nmap^ ${keys} {target}$          | map for %Normal% mode              |
  | ^vmap^ ${keys} {target}$          | map for %Visual% mode (and Select) |
  | ^imap^ ${keys} {target}$          | map for %Insert% mode              |
  | ^omap^ ${keys} {target}$          | map for %Operator-pending% mode    |
  | ^cmap^ ${keys} {target}$          | map for %Command-line% mode        |
  | {$mode$}^noremap^ ${keys} {target}$ | avoid recursive mapping          |
  | {$mode$}^unmap^ ${keys}$            | remove mapping                   |
  | let g:mapleader = ','         | set $,$ as $<Leader>$                |

# Config > Key Mapping Examples

  • {{{vim nnoremap <Leader>w :w<CR> <}}}
    => $,w$ to save buffer to file <

  • {{{vim nnoremap <C-j> <C-w>j <}}}
    => $<C-j>$ to move to window below <

  • {{{vim nnoremap <Leader>J <C-w>J <}}}
    => $,j$ to move to window below current <

  • {{{vim nnoremap \| :vsplit<CR> <}}}
    => $|$ to virtically split current buffer <

  • {{{vim nnoremap <C-d> <C-d>zz}}}
    => $<C-d>$ to scroll half page down and center current line vertically in window <

  • {{{vim nnoremap <expr> j (v:count > 1 ? "m'" . v:count : '') . 'gj' <}}}
    => $j$ to move down one virtual line <
    => [%n%]$j$ to move down %n% virtual line(s) and last postion to jumplist <

  • {{{vim onoremap <silent> i, :normal! t,vT,<CR>}}}
    => Operator-pending map for text object between commas in a line. <
       We can do things like $ci,$, $di,$ and $yi,$.
    <
  • {{{vim nnoremap <leader>cc "+y}}}
    => $,cc$ + %motion% to copy to system clipboard <

  • {{{vim nnoremap <Leader>cs :let @+=expand('\%:t')<CR>}}}
    => $,cs$ to copy current file name to clipboard <
    {{{vim nnoremap <Leader>cl :let @+=expand('%:p')<CR>}}}
    => $,cl$ to copy current file with absolute path to clipboard <
    {{{vim nnoremap <Leader>cr :let @+=util#ExpandRelative('%:p')<CR>}}}
    => $,cr$ to copy current file with relative path to working dir to clipboard <

# Plugin > Color Candies

  | Plugin                           | Description                          | <
  | -------------------------------- | ------------------------------------ |
  | ^Plug^ $'nviennot/molokai'$          | %molokai% color scheme                 | <
  | ^Plug^ $'pangloss/vim-javascript'$   | %javascript% file syntax highlighting  | <
  | ^Plug^ $'mxw/vim-jsx'$               | %jsx% file syntax highlighting         | <
  | ^Plug^ $'hail2u/vim-css3-syntax'$    | %css% file syntax highlighting         | <
  | ^Plug^ $'cakebaker/scss-syntax.vim'$ | %scss% file syntax highlighting        | <
  | ^Plug^ $'elzr/vim-json'$             | %json% file syntax highlighting        | <
  | ^Plug^ $'vim-python/python-syntax'$  | %python% file syntax highlighting      | <
  | ^Plug^ $'vim-ruby/vim-ruby'$         | %ruby% file syntax highlighting        | <
  | ^Plug^ $'plasticboy/vim-markdown'$   | %markdown% file syntax highlighting    | <
  | ^Plug^ $'solarnz/thrift.vim'$        | %thrift% file syntax highlighting      | <
  | ^Plug^ $'keith/swift.vim'$           | %swift% file syntax highlighting       | <
  | ^Plug^ $'b4winckler/vim-objc'$       | %objective c% file syntax highlighting | <
  | ^Plug^ $'vim-scripts/nginx.vim'$     | %nginx% file syntax highlighting       | <

# Plugin > New Era

  | Plugin                                | Description                           | <
  | ------------------------------------- | ------------------------------------- |
  | ^Plug^ $'vim-airline/vim-airline'$        | %improved status line%                  | <
  | ^Plug^ $'vim-airline/vim-airline-themes'$ | %airline themes%                        | <
  | ^Plug^ $'sjl/gundo.vim'$                  | %visualize undo tree%                   | <
  | ^Plug^ $'vim-scripts/YankRing.vim'$       | %history of yanks, changes and deletes% | <
  | ^Plug^ $'scrooloose/nerdtree'$            | %improved tree explorer%                | <
  | ^Plug^ $'majutsushi/tagbar'$              | %outline viewer%                        | <
  | ^Plug^ $'yssl/QFEnter'$                   | %ways to open a quickfix list item%     |

# Plugin > Find

  | Plugin                                | Description                | <
  | ------------------------------------- | -------------------------- |
  | ^Plug^ $'ctrlpvim/ctrlp.vim'$             | %ctrlp fuzzy file finder%    | <
  | ^Plug^ $'junegunn/fzf'$                   | %fzf file finder%            | <
  | ^Plug^ $'junegunn/fzf.vim'$               | %fzf vim bindings%           | <
  | ^Plug^ $'bronson/vim-visual-star-search'$ | %search for visual selction% | <
  | ^Plug^ $'mhinz/vim-grepper'$              | %async search grep tool%     | <
  | ^Plug^ $'tpope/vim-abolish'$              | %variants of a word%         | <
  | ^Plug^ $'tpope/vim-unimpaired'$           | %pairs of mapping%           |

# Plugin > Move

  | Plugin                                 | Description                      | <
  | -------------------------------------- | -------------------------------- |
  | ^Plug^ $'easymotion/vim-easymotion'$       | %fancy (yet useful) way of motion% |
  | ^Plug^ $'kana/vim-textobj-user'$           | %custom text object%               |
  | ^Plug^ $'kana/vim-textobj-line'$           | %line text object%                 |
  | ^Plug^ $'bps/vim-textobj-python'$          | %python text object%               |
  | ^Plug^ $'michaeljsmith/vim-indent-object'$ | %indent text object%               |
  | ^Plug^ $'terryma/vim-expand-region'$       | %expand/shrink visual selection%   |


# Plugin > Edit

  | Plugin                                | Description                   | <
  | ------------------------------------- | ----------------------------- |
  | ^Plug^ $'tpope/vim-surround'$             | %add, change or delete pairs%   |
  | ^Plug^ $'Valloric/YouCompleteMe'$         | %autocomplete engine%           |
  | ^Plug^ $'jiangmiao/auto-pairs'$           | %auto insert pairs%             |
  | ^Plug^ $'alvan/vim-closetag'$             | %auto close end tag%            |
  | ^Plug^ $'tpope/vim-endwise'$              | %auto close end token%          |
  | ^Plug^ $'tpope/vim-commentary'$           | %comment%                       |
  | ^Plug^ $'SirVer/ultisnips'$               | %snippets engine%               |
  | ^Plug^ $'honza/vim-snippets'$             | %snippets library%              |
  | ^Plug^ $'godlygeek/tabular'$              | %align text%                    |
  | ^Plug^ $'millermedeiros/vim-esformatter'$ | %flexible javascript formatter% |


# Plugin > Integration

  | Plugin                        | Description                            | <
  | ----------------------------- | -------------------------------------- |
  | ^Plug^ $'w0rp/ale'$               | %async lint engine%                      |
  | ^Plug^ $'airblade/vim-gitgutter'$ | %git diff gutter visualizer%             |
  | ^Plug^ $'tpope/vim-fugitive'$     | %best git wrapper ever%                  |
  | ^Plug^ $'janko-m/vim-test'$       | %run your tests at the speed of thought% |
  | ^Plug^ $'benmills/vimux'$         | %tmux integration%                       |

# Plugin > Misc

  | Plugin                               | Description               | <
  | ------------------------------------ | ------------------------- |
  | ^Plug^ $'machakann/vim-highlightedyank'$ | %highlight yanked%          |
  | ^Plug^ $'xolox/vim-notes'$               | %note%                      |
  | ^Plug^ $'tpope/vim-repeat'$              | %repeat . for plugin%       |
  | ^Plug^ $'gerw/vim-HiLinkTrace'$          | %inspect syntax highlight%  |
  | ^Plug^ $'ton/vim-bufsurf'$               | %buffer history per window% |
  | ^Plug^ $'tmhedberg/SimpylFold'$          | %better python fold%        |
  | ^Plug^ $'vim-scripts/L9'$                | %scripting utils%           |
  | ^Plug^ $'xolox/vim-misc'$                | %scripting utils%           |

# Script > Intro

  • Vim is powerful out of the box <
  • Vim is even more powerful with $config$ and $plugins$ <
  • Vim shines more with $scripting$ <

# Script > Print

  • $echo$ => print a message <
    {{{vim echo 'Hello world'}}}
  • $echom$ => print a message and persist <
    {{{vim echom 'Hello world'}}}
  • $mes$sages => show messages <
    {{{vim echom 'Hello world'}}}

# Script > Set Option

  • $set$ => set option <
    {{{vim set list}}}
    {{{vim set nolist}}}
    {{{vim set list!}}}
    {{{vim set textwidth=120}}}
    {{{vim set list?}}}

  • $setlocal$ => set local option <
    {{{vim setlocal list}}}

# Script > Autocommmand

  {{{vim autocmd BufWritePost *.vim source %}}}
  ▸ BufWritePost => $event$ <
  ▸ {{{txt *.vim}}} => $pattern$ <
  ▸ source % => $command$ <
  ▸ Automatically source the vim script after save <

  {{{vim autocmd filetype python setlocal tabstop=4}}}
  ▸ Set tabstop to 4 for python file <

# Script > Normal & Execute

  {{{vim normal gg}}}
  {{{vim normal! gg}}}
  {{{vim normal! /abc<CR>}}}
  {{{vim execute 'normal! /abc\<CR>'}}}

# Script > Variables

  ## Variables <

  {{{vim let a = 100}}}
  {{{vim echo a}}}
  {{{vim echo &textwidth}}}
  {{{vim echo &wrap}}}
  {{{vim set textwidth=a}}} ?
  {{{vim let &textwidth = &textwidth + 20}}}
  {{{vim let &l:textwidth = 120}}}
  {{{vim echo @"}}}
  {{{vim let @a = 'hi register a'}}}
  {{{vim let g:a = 'hi global'}}}
  {{{vim let s:a = 'hi script'}}}
  {{{vim let b:a = 'hi local'}}}

# Script > Logic

  • $If$ <

  {{{vim if 0
    echo 'true'
  elseif 'no'
    echo 'elseif'
  else
    echo 'else'
  endif}}}

  • $Compare$ <

  $==$ %depends% on config <
  $==#$ case %sensitive% regardless of config <
  $==?$ case %insensitive% regardless of config <

# Script > Function

  {{{vim function Hello()
    return 'hello'
  endfunction

  call Hello()
  echo Hello()}}}

# Script > Function

  {{{vim function Hello()
    echo 'hello'
  endfunction

  call Hello()
  echo Hello()}}}

# Script > Function

  {{{vim function Hello(name)
    echo a:name
  endfunction

  call Hello('name')}}}

# Script > Function

  {{{vim function Hello(name, ...)
    echo a:name
    echo a:0
    echo a:1
    echo a:000
  endfunction

  call Hello('name', 'another', 'yet another')}}}

# Script > Number

  ## Number <

  {{{vim echo 3 / 2}}}
  {{{vim echo 3 / 2.0}}}
  {{{vim echo 010}}}

# Script > String

  ## String <

  {{{vim echo 'Hello ' + 'world'}}}
  {{{vim echo 'Hello ' . 'world'}}}
  {{{vim echo 'Hello \nworld'}}}
  {{{vim echo "Hello \nworld"}}}

# Script > String

  ## Functions <

  • $len$ => length of string in bytes <
    {{{vim echo len('Hello world')}}}
  • $strlen$ => length of string in bytes <
    {{{vim echo strlen('Hello world')}}}

  • $printf$ => format a string <
    {{{vim echo printf('%s %s', 'Hello', 'world')}}}
  • $expand$ => expand special keywords <
    {{{vim echo expand('%:p')}}}
  • $repeat$ => repeat a string by times <
    {{{vim echo repeat('-', 10)}}}

  • $split$ => split string to list <
    {{{vim echo split('Hello world')}}}
    {{{vim echo split('Hello,world', ',')}}}
    {{{vim echo join(split('Hello world'), ',')}}}

  • $tolower$ => make lowercase <
    {{{vim echo tolower('Hello world')}}}
  • $toupper$ => make uppercase <
    {{{vim echo toupper('Hello world')}}}

# Script > List

  • $List$ <
  {{{vim let list = ['hello', [1, 'world']]}}}

  • $Index$ <
  {{{vim echo ['hello', [1, 'world']][1]}}}
  {{{vim echo ['hello', [1, 'world']][-1]}}}

  • $Slice$ <
  {{{vim echo ['a', 'b', 'c', 'd'][0:2]}}}
  {{{vim echo ['a', 'b', 'c', 'd'][0:999]}}}
  {{{vim echo ['a', 'b', 'c', 'd'][-2:-1]}}}
  {{{vim echo ['a', 'b', 'c', 'd'][:2]}}}
  {{{vim echo ['a', 'b', 'c', 'd'][1:]}}}

  • $Concate$ <
  {{{vim echo ['a', 'b'] + ['c']}}}

  • $Unpack$ <
  {{{vim let [v1, v2; rest] = ['a', 'b', 'c', 'd']}}}

# Script > List

  ## Functions <

  • $len$ => length of list <
    {{{vim echo len(['a', 'b', 'c'])}}}
  • $empty$ => check if list is empty <
    {{{vim echo empty(['a', 'b', 'c'])}}}

  • $split$ => split string to list <
    {{{vim echo split('a b c')}}}
  • $join$ => join list into string <
    {{{vim echo join(['a', 'b', 'c'], ',')}}}
  • $range$ => list of numbers <
    {{{vim echo range(1, 6, 2)}}}
  • $repeat$ => repeat a list by times <
    {{{vim echo repeat([1, 2], 3)}}}

  • $get$ => get item by index <
    {{{vim echo get(['a', 'b', 'c'], 0, 'default')}}}
    {{{vim echo get(['a', 'b', 'c'], 999, 'default')}}}
  • $index$ => index of value in list <
    {{{vim echo index(['a', 'b', 'c'], 'a')}}}

# Script > List

  ## Functions

  • $insert$ => insert item to list <
    {{{vim echo insert(list, 'another')}}}
    {{{vim echo insert(list, 'another', 2)}}}
  • $add$ => append item to list <
    {{{vim echo add(list, 'another')}}}
    {{{vim echo add(list, [1, 2])}}}
  • $extend$ => append list to list <
    {{{vim echo extend(list, [1, 2])}}}
  • $remove$ => remove items in list <
    {{{vim echo remove(list, 1)}}}
    {{{vim echo remove(list, 1, -1)}}}

  • $reverse$ => reverse order of list <
    {{{vim echo reverse(['a', 'b', 'c'])}}}
  • $sort$ => sort list <
    {{{vim echo sort(['a', 'c', 'b'])}}}
  • $uniq$ => remove repeated adjacent items <
    {{{vim echo uniq(['a', 'c', 'a'])}}}
    {{{vim echo uniq(sort(['a', 'c', 'a']))}}}

# Script > Loop

  • $For$ <

  {{{vim for i in [1, 2, 3]
    echo i
  endfor}}}

  • $While$ <

  {{{vim let a = 0
  while a < 3
    echo a
    let a += 1
  endwhile}}}

# Script > Dictionary

  ## Dictionary <

  • $create$ <
  {{{vim let dict = {'key': 1, 100: 'value'} }}}
  • $assign$ <
  {{{vim let dict.key = 'new value'}}}
  {{{vim let dict.another = 'another value'}}}

  ## Functions <

  • $empty$ => check if dict is empty <
    {{{vim echo empty(dict)}}}
  • $len$ => number of items in dict <
    {{{vim echo len(dict)}}}

  • $has_key$ => check if a key in dict <
    {{{vim echo has_key(dict, 'third')}}}
  • $get$ => get value by key <
    {{{vim echo get(dict, 'third', 'default')}}}
  • $keys$ => get keys <
    {{{vim echo keys(dict)}}}
  • $values$ => get values <
    {{{vim echo values(dict)}}}
  • $items$ => get entries pair <
    {{{vim echo items(dict)}}}

  • $remove$ => remove entry from dict <
    {{{vim echo remove(dict, 'key')}}}
  • $extend$ => add entries to dict <
    {{{vim echo extend(dict, {'key': 'val'})}}}

# Script > Essential Functions

  • $List and Dictionary$ <

  | Function | Description               | <
  | -------- | ------------------------- |
  | $min$      | minimum value             | <
  | $max$      | maximum value             | <
  | $count$    | count of value appearance | <
  | $copy$     | shallow copy              | <
  | $deepcopy$ | deep copy                 | <
  | $filter$   | select item               | <
  | $map$      | change each item          | <

# Script > Essential Functions

  • $Cursor$ <

  | Function | Description                  | <
  | -------- | ---------------------------- |
  | $line$     | line number of cursor/mark   | <
  | $col$      | column number of cursor/mark | <
  | $getpos$   | get postion of cursor/mark   | <
  | $cursor$   | put cursor at line/column    | <
  | $setpos$   | set postion of cursor/mark   | <

# Script > Essential Functions

  • $Buffer$ <

  | Function     | Description                  | <
  | ------------ | ---------------------------- |
  | $getline$      | get lines from buffer        | <
  | $setline$      | set lines in buffer          | <
  | $append$       | append lines in buffer       | <
  | $nextnonblank$ | find next non-blank line     | <
  | $prevnonblank$ | find previous non-blank line | <
  | $search$       | search for pattern           | <
  | $searchpos$    | search for pattern           | <
  | $searchpair$   | search for start-end pair    | <

# Script > User Command

  • $command$ => define a user command <
    {{{vim command Hello call Hello()}}}
    {{{vim command -nargs=1 Hello call Hello(<args>)}}}

# Script > Local Mappings

  • $<SID>$ => use script scope function in mapping <
    {{{vim nnoremap <leader>h :call <SID>Hello()<CR>}}}

  • $<Plug>$ => allow customize mapping for commands
    {{{vim noremap <Plug>Hello :Hello<CR>}}}
    {{{vim nmap <leader>h <Plug>Hello}}}

# Thanks

{{{ascii
 QQQ   U   U EEEE  SSS  TTTTTT III  OOO  N   N  SSS   ???
Q   Q  U   U E    S       TT    I  O   O NN  N S     ?   ?
Q   Q  U   U EEE   SSS    TT    I  O   O N N N  SSS     ?
Q  QQ  U   U E        S   TT    I  O   O N  NN     S   ?
 QQQQ   UUU  EEEE SSSS    TT   III  OOO  N   N SSSS    ?
     Q
}}}
