$MASTER VIM THE PRACTICAL WAY$

- Bin

# About

  • Covers Vim essentials <
  • Covers more advanced Vim <
  • Covers many useful tips <
  • Helps you to be a Vim master <
  • Does NOT make you a Vim master (Practice!) <
  • Covers only small portion of Vim's power <
  • Vim is just one part of the flow <


# What is Vim?

{{{ascii
TTTTTT EEEE X   X TTTTTT     EEEE DDD  III TTTTTT  OOO  RRRR
  TT   E     X X    TT       E    D  D  I    TT   O   O R   R
  TT   EEE    X     TT       EEE  D  D  I    TT   O   O RRRR
  TT   E     X X    TT       E    D  D  I    TT   O   O R R
  TT   EEEE X   X   TT       EEEE DDD  III   TT    OOO  R  RR
}}}

# Why Vim?

  ## Efficiency <
    • No mouse
    • No ambiguity
    • Powerful modal editing
    • Designed for DRY (_Don't Repeat Yourself_)

  ## Performance <
    • Lightweight

  ## Customization <
    • Config
    • Plugin
    • Script
    • Integration

  ## Documentation <
    • Comprehensive documentation

# How to Start?

  ## Touch Typing <
    • The foundation <
    • Practice more for numbers and special characters

  ## Vimtutor <
    • {{{sh $ vimtutor }}}

  ## Minimal Config <
    • Minimal %.vimrc% config to start with

    {{{vim " .vimrc
    set nocompatible
    syntax on
    filetype plugin indent on }}}

# How to Start?

  • The very $essential commands$ to get started <

  | Command          | Description                                   | <
  | ---------------- | --------------------------------------------- |
  | $h$, $j$, $k$, $l$       | ^move^ %left%, %down%, %up%, %right%                    | <
  | :w               | ^write^ to $file$                                 | <
  | :q               | ^quit^ $window$                                   | <
  | :q!              | ^quit^ $window$ (%discard changes%)                 | <
  | :e {file}        | ^edit^ $file$ in window                           | <
  | :e {dir}         | ^open^ $dir$ in file browser                      | <
  | $w$                | ^move^ to the %next% $start of word$                | <
  | $b$                | ^move^ to the %previous% $start of word$            | <
  | $$$                | ^move^ to the $end of line$                       | <
  | $0$                | ^move^ to the $beginning of line$                 | <
  | $gg$               | ^move^ to the $first line$                        | <
  | $G$                | ^move^ to the $last line$                         | <
  | [n]$gg$            | ^move^ to $line$ %n%                                | <
  | $<C-d>$            | ^move^ $half page$ %down%                           | <
  | $<C-u>$            | ^move^ $half page$ %up%                             | <
  | $i$                | ^insert^ %before%                                 | <
  | $a$                | ^append^ %after%                                  | <
  | $<ESC>$            | ^return^ to $Normal$ mode                         | <
  | $dd$               | ^delete^ $current line$                           | <
  | $dw$               | ^delete^ %until next% $start of word$ (exclusive)   | <
  | $u$                | ^undo^ $last edit$                                | <
  | $<C-r>$            | ^redo^ $last edit$                                | <
  | $yy$               | ^yank^ $current line$                             | <
  | $p$                | ^paste^ %after%                                   | <
  | $/${pattern}$<CR>$   | ^search^ %forward% for ${pattern}$                  | <
  | $:%s$/old/new/[gc] | ^substitute^ in $file$                            | <

# Contents

  • Modes <
  • Move <
  • Edit <
  • Visual <
  • Command <
  • Repeat <
  • Search <
  • Files <
  • Config <
  • Plugin <
  • Script <

# Key Takeaways

  • $Count + Operator + Motion$ <

  • $Don't Repeat Yourself$ <

  • $Customize + Scripting$ <

# Modes

  • Normal <
  • Insert <
  • Command-line <
  • Visual <
  • Operator-pending <
  • Replace <

# Modes > Switch between Modes

  • Vim is in $Normal$ mode when it launches. <
  • We can switch between different modes <

  | Command                    | Description                     | <
  | -------------------------- | ------------------------------- |
  | Normal + $a,A,C,i,I,o,O,s,S$ | ^switch^ to $Insert$ mode           | <
  | Normal + $:,/,?$             | ^switch^ to $Command-line$ mode     | <
  | Normal + $v,V,<C-v>$         | ^switch^ to $Visual$ mode           | <
  | Normal + $c,d,y$             | ^switch^ to $Operator-pending$ mode | <
  | Normal + $R$                 | ^switch^ to $Replace$ mode          | <
  | ANY + $<ESC>$                | ^switch^ to $Normal$ mode           | <

# Move

  • Moving around is one $crucial$ part of the flow when using Vim <
  • ^Avoid^ using $arrow keys$ to move <
  • ^Avoid^ move in $Insert$ mode <
  • Better to ^avoid^ using %repeated% $h/j/k/l$ to move <
  • Most moves can be ^repeated^ by $count$ <

# Move > Move by direction

  • $h/j/k/l$ can be repeated by $count$ <

  | Command | Description               | <
  | ------- | ------------------------- |
  | [n]$h$    | ^move^ %n% $character(s)$ %left%  | <
  | [n]$j$    | ^move^ %n% $line(s)$ %down%       | <
  | [n]$k$    | ^move^ %n% $line(s)$ %up%         | <
  | [n]$l$    | ^move^ %n% $character(s)$ %right% | <

# Move > Move by word

  • A $word$ is a sequence of letters, digits, understores or other non-blank characters. <
  • It can be customized with $iskeyword$.
  • Move by $word$ is useful and much faster than move by single character.

  | Command | Description                            | <
  | ------- | -------------------------------------- |
  | [n]$w$    | ^move^ to the %nth next% $start of word$     | <
  | [n]$b$    | ^move^ to the %nth previous% $start of word$ | <
  | [n]$e$    | ^move^ to the %nth next% $end of word$       | <
  | [n]$ge$   | ^move^ to the %nth previous% $end of word$   | <

# Move > Move by WORD

  • A $WORD$ is a sequence of $non-blank characters$ separated by white space. <
  • Move by $WORD$ is preferred in certain cases.

  | Command | Description                            | <
  | ------- | -------------------------------------- |
  | [n]$W$    | ^move^ to the %nth next% $start of WORD$     | <
  | [n]$B$    | ^move^ to the %nth previous% $start of WORD$ | <
  | [n]$E$    | ^move^ to the %nth next% $end of WORD$       | <
  | [n]$gE$   | ^move^ to the %nth previous% $end of WORD$   | <

# Move > Move in line by line boundary

  • Move using $$$, $0$, $^$ is a quicker way to navigate to / between ends of current line. <

  | Command | Description                                               | <
  | ------- | --------------------------------------------------------- |
  | $0$       | ^move^ to the $beginning$ of line                             | <
  | $^$       | ^move^ to the $first non-blank character$ of line             | <
  | [n]$$$    | ^move^ to the $end$ of %(n-1)th next% line                      | <
  | [n]$g_$   | ^move^ to the $last non-blank character$ of %(n-1)th next% line | <

# Move > Move in line by finding character

  • Move using $f$, $t$ is a more precise way. <
  • Be aware of the $choice$ of {c}.

  | Command | Description                                                      | <
  | ------- | ---------------------------------------------------------------- |
  | [n]$f{c}$ | ^move^ %to% the %nth next% $occurrence of {c}$ in line                   | <
  | [n]$t{c}$ | ^move^ %till% the %nth next% $occurrence of {c}$ in line (exclusive)     | <
  | [n]$F{c}$ | ^move^ %to% the %nth previous% $occurrence of {c}$ in line               | <
  | [n]$T{c}$ | ^move^ %till% the %nth previous% $occurrence of {c}$ in line (exclusive) | <
  | [n]$;$    | ^repeat^ $last find$ %n times% in line                                 | <
  | [n]$,$    | ^repeat^ $last find$ %n times% in line in %opposite direction%           | <

# Move > Cursor and Window

  • $Cursor$ position vs $Window$ position <
  • Vim always make sure cursor is %inside% window <
  • The window position depends on $scrolloff$ config <

# Move > Move in file by line

  • Use $gg$ or $G$ to move to line <

  | Command | Description            | <
  | ------- | ---------------------- |
  | $gg$      | ^move^ to the $first line$ | <
  | $G$       | ^move^ to the $last line$  | <
  | [n]$gg$   | ^move^ to $line$ %n%       | <
  | [n]$G$    | ^move^ to $line$ %n%       | <

# Move > Move by page

  • Move faster by $page$ <
  • More useful to $navigate$ rather than position
  • Harder to foresee the exact position

  | Command | Description                           | <
  | ------- | ------------------------------------- |
  | $<C-d>$   | ^move^ $cursor$ %half page down%            | <
  | $<C-u>$   | ^move^ $cursor$ %half page up%              | <
  | $<C-f>$   | ^move^ $window$ %one page down%             | <
  | $<C-b>$   | ^move^ $window$ %one page up%               | <
  | $H$       | ^move^ $cursor$ to %"first line"% in $window$ | <
  | $M$       | ^move^ $cursor$ to %middle line% in $window$  | <
  | $L$       | ^move^ $cursor$ to %"last line"% in $window$  | <

# Move > Move by object

  • Move by $sentence$ and $paragraph$ <

  | Command | Description                                 | <
  | ------- | ------------------------------------------- |
  | [n]$($    | ^move^ to the %beginning% of %previous% $sentence$  | <
  | [n]$)$    | ^move^ to the %beginning% of %next% $sentence$      | <
  | [n]${$    | ^move^ to the %beginning% of %previous% $paragraph$ | <
  | [n]$}$    | ^move^ to the %beginning% of %next% $paragraph$     | <

# Move > Move by search

  • We can also use pattern $search$ to move around <
  • More in $Search$ section

  | Command        | Description                           | <
  | -------------- | ------------------------------------- |
  | $*$              | ^search^ %forward% for $word under cursor$  | <
  | $#$              | ^search^ %backward% for $word under cursor$ | <
  | $/${pattern}$<CR>$ | ^search^ %forward% for ${pattern}$          | <
  | $?${pattern}$<CR>$ | ^search^ %backward% for pattern ${pattern}$ | <
  | $n$              | ^move^ to the %next% $match$                | <
  | $N$              | ^move^ to the %previous% $match$            | <

# Move > Move by match

  • We can also move around using $([{$ semantics <

  | Command | Description                                                | <
  | ------- | ---------------------------------------------------------- |
  | $%$       | ^find^ $([{ in line$ and ^move^ to the $matching close$            | <
  | $[{$      | ^go^ to %previous% $unmatched {$ (%beginning% of $outer code block$) | <
  | $]}$      | ^go^ to %next% $unmatched }$ (%end% of $outer code block$)           | <
  | $[($      | ^go^ to %previous% $unmatched ($ (%beginning% of $outer func param$) | <
  | $])$      | ^go^ to %next% $unmatched )$ (%end% of $outer func param$)           | <

# Move > Move by mark

  • Mark is useful for $remember$ a location <
  • Take advantage of $special marks$

  | Command | Description                             | <
  | ------- | --------------------------------------- |
  | $m${mark} | ^add^ a $mark$                              | <
  | $`${mark} | ^goto^ a $mark$ (%exact position%)            | <
  | $'${mark} | ^goto^ a $mark$ (%first non-blank character%) | <

  | Marks  | Description                              | <
  | ------ | ---------------------------------------- |
  | ${a-z}$  | $local$ mark in file                       | <
  | ${A-Z}$  | $global$ mark                              | <
  | $.$      | $last edited$                              | <
  | $'$      | $latest jump$                              | <
  | $`$      | $latest jump$                              | <
  | $"$      | $last position$ before leave buffer        | <
  | $^$      | $last insert$ position                     | <
  | $[$      | %beginning% of $last changed or yanked$ text | <
  | $]$      | %end% of $last changed or yanked$ text       | <
  | $<$      | %beginning% of $last visual select$          | <
  | $>$      | %end% of $last visual select$                | <

# Move > Move by jumps

  • $jumplist$ maintains jumps history, we can use it to jump back and forth <

  | Command | Description                        | <
  | ------- | ---------------------------------- |
  | $<C-o>$   | ^jump^ to %older% position in $jumplist$ | <
  | $<C-i>$   | ^jump^ to %newer% position in $jumplist$ | <
  | $:jumps$  | ^list^ $jumps history$                 | <

# Move > Move by changes

  • $changelist$ maintains changes history, we can use it to jump back and forth as well <

  | Command  | Description                          | <
  | -------- | ------------------------------------ |
  | $g;$       | ^jump^ to %older% position in $changelist$ | <
  | $g,$       | ^jump^ to %newer% position in $changelist$ | <
  | $gi$       | ^insert^ at $last insert position$       | <
  | $:changes$ | ^list^ $changes history$                 | <

# Edit > Edit in Normal mode

  • Basic commands to edit text in $Normal$ mode only <

  | Command        | Description                        | <
  | -------------- | ---------------------------------- |
  | [n]$x$           | ^delete^ $current character$           | <
  | [n]$r${c}        | ^replace^ $current character$ with %{c}% | <
  | [n]$dd$          | ^delete^ $current line$                | <
  | [n]$D$           | ^delete^ to $end of current line$      | <
  | [n]$d${%motion%}   | ^delete^ using %motion%                | <
  | [n]$J$           | ^join^ $lines$                         | <

# Edit > Enter Insert mode

  • There are various ways to ^enter^ $Insert$ mode <
  • Many of them have additional move benefits.

  | Command | Description                             | <
  | ------- | --------------------------------------- |
  | $a$       | ^append^ %after% $cursor$                     | <
  | $A$       | ^append^ %after% $end of line$                | <
  | $i$       | ^insert^ %before% $cursor$                    | <
  | $I$       | ^insert^ %before% $first non-blank character$ | <
  | $o$       | ^insert^ %below% $line$                       | <
  | $O$       | ^insert^ %above% $line$                       | <
  | $s$       | ^change^ %current% $character$                | <
  | $C$       | ^change^ %current% $line$                     | <
  | $cc$      | ^change^ %current% $line$                     | <

# Edit > Edit in Insert mode

  • There are various ways to ^edit^ in $Insert$ mode <

  | Command        | Description                                  | <
  | -------------- | -------------------------------------------- |
  | $typing$         | ^typing^ to edit                               | <
  | $<BS>$           | ^delete^ %left%                                  | <
  | $<DEL>$          | ^delete^ %right%                                 | <
  | $<C-w>$          | ^delete^ %left% $a word$                           | <
  | $<C-u>$          | ^delete^ %left to% $first non-blank word$          | <
  | $<C-r>${reg}     | ^insert^ $register {reg}$                      | <
  | $<C-r>=$         | ^insert^ $eval result of an expression$          | <
  | $<C-v>${c}       | ^insert^ ${c}$ %literally%                         | <
  | $<C-k>${digraph} | ^insert^ ${digraph}$                             | <
  | $<C-o>$          | ^run^ $a Normal command$ and ^back^ to $Insert$ mode | <

# Edit > Count + Operator + Motion

  $Count$ + ^Operator^ + %Motion% <
  • $Count$: an arbitrary number (_how many_) <
  • ^Operator^: an action (_what_) <
  • %Motion%: a descriptive (_where_) <

# Edit > Operator

  • ^Operator^: an action (_what to do_) <

  | Command | Description  | <
  | ------- | ------------ |
  | $c$       | ^change^       | <
  | $d$       | ^delete^       | <
  | $y$       | ^yank^         | <
  | $=$       | ^auto indent^  | <
  | $>$       | ^indent^ %right% | <
  | $<$       | ^indent^ %left%  | <
  | $~$       | ^swap case^    | <
  | $gu$      | ^lower case^   | <
  | $gU$      | ^upper case^   | <

# Edit > Motion

  • %Motion%: a descriptive (_where_) <
    ◦ $All move commands$ mentioned before (_almost_) <
    ◦ $Text Object$ <

# Edit > Text Object

  • $Selection Mode$ <
    ◦ $i$: %inside% (exclusive)
    ◦ $a$: %around% (inclusive)

  • $Text Objects$ <

    | Command | Description    | <
    | ------- | -------------- |
    | $w$       | $word$           | <
    | $W$       | $WORD$           | <
    | $s$       | $sentence$       | <
    | $p$       | $paragraph$      | <
    | $t$       | $xml tag$        | <
    | $'$       | $single quotes$  | <
    | $"$       | $double quotes$  | <
    | $`$       | $backticks$      | <
    | $[$,$]$     | $brackets$       | <
    | $($,$)$     | $parentheses$    | <
    | ${$,$}$     | $braces$         | <
    | $<$,$>$     | $angle brackets$ | <

  • $Custom Text Objects$ <

# Edit > Count + Operator + Motion

  $Count$ + ^Operator^ + %Motion% <

  • It is an atomic action and can be repeated using $.$ command <
  • Let's see some examples <

  | Command | Description             | <
  | ------- | ----------------------- |
  | $daw$     | ^delete^ %around% $word$      | <
  | $dap$     | ^delete^ %around% $paragraph$ | <
  | $cib$     | ^change^ %inside% $()$        | <
  | $cit$     | ^change^ %inside% $tag$       | <
  | $ct,$     | ^change^ %until% $,$          | <
  | $yaB$     | ^yank^ %around% ${}$          | <

# Edit > Registers

  • Registers are the enhanced "clipboards" in Vim <

  | Register | Description               | <
  | -------- | ------------------------- |
  | $"$        | %unnamed% (any last change) | <
  | $0$        | %yank%                      | <
  | $1$-$9$      | %delete% (1 is the newest)  | <
  | ${a-z}$    | %named% $register$ (replace)  | <
  | ${A-Z}$    | %named% $register$ (append)   | <
  | $%$        | %current file%              | <
  | $#$        | %alternative file%          | <
  | $:$        | %last ex command%           | <
  | $/$        | %last search%               | <
  | $+$        | %system clipboard%          | <
  | $*$        | %primary clipboard%         | <
  | $.$        | %last inserted text%        | <
  | $=$        | %expression%                | <
  | $-$        | %small change% (in a line)  | <

# Edit > Registers

  • How to use registers <

  | Command         | Description                                         | <
  | --------------- | --------------------------------------------------- |
  | $"${reg}$y${%motion%} | ^set^ $register {reg}$                                  | <
  | $"${reg}$p$         | ^put^ $register {reg}$                                  | <
  | $:reg$isters      | ^show^ $registers$                                      | <
  | $<C-r>${reg}      | ^insert^ $register {reg}$ (in $Insert$/$Command-line$ mode) | <

# Edit > Yank & Put

  • Yank is "Copy" in Vim <
  • Put is "Paste" in Vim

  | Command           | Description               | <
  | ----------------- | ------------------------- |
  | [n]$yy$             | ^yank^ $line(s)$              | <
  | [n]$Y$              | ^yank^ $line(s)$              | <
  | [$"{reg}$]$y${%motion%} | ^yank^ to $register {reg}$    | <
  | [$"{reg}$]$p$         | ^put^ $register {reg}$ %after%  | <
  | [$"{reg}$]$P$         | ^put^ $register {reg}$ %before% | <

# Edit > Yank & Put use cases

  • $xp$ <
    => ^swap^ $character$ <

  • $ddp$ <
    => ^swap^ $line$ <

  • $yyp$ <
    => ^duplicate^ $line$ <

  • swap two adjacent words? <
    => $dwwhp$ <
    => $dww^P^$ <
    => $d^e^wP^ldebh^P$ <
    => $de^mm^wPlde^`m^P$ <
    => $d^iw^mmwPlde`mP$ <

# Edit > Undo & Redo

  • Undo and Redo (revert undo) is common, but Vim gives us a more sophisticated one. <

  | Command  | Description                       | <
  | -------- | --------------------------------- |
  | [n]$u$     | ^undo^ $change(s)$                    | <
  | [n]$<C-r>$ | ^redo^ $changes(s)$                   | <
  | $U$        | ^undo^ $all latest changes in a line$ | <

# Edit > Undo Branchs

  • Undos can $branch$ off <
  • We can undo by time sequence <

  | Command               | Description                                 | <
  | --------------------- | ------------------------------------------- |
  | [n]$g-$                 | ^go to^ %older% $state$                           | <
  | [n]$g+$                 | ^go to^ %newer% $state$                           | <
  | $:ea$rlier {n}          | ^go to^ %older% $state$                           | <
  | $:ea$rlier {n}%s/m/h/d/f% | ^go to^ %older% $state$ about certain time %before% | <
  | $:lat$er {n}            | ^go to^ %newer% $state$                           | <
  | $:lat$er {n}%s/m/h/d/f%   | ^go to^ %newer% $state$ about certain time %after%  | <

# Visual > Enter Visual mode

  • There are three ways to enter slightly different $Visual$ mode <

  | Command | Description                      | <
  | ------- | -------------------------------- |
  | $v$       | ^switch to^ %normal% $Visual$ mode     | <
  | $V$       | ^switch to^ %line-wise% $Visual$ mode  | <
  | $<C-v>$   | ^switch to^ %block-wise% $Visual$ mode | <

  • These commands can be used to ^switch^ between different modes as well <

  • We can ^reselect^ the $last visual selection$ using $gv$ <

# Visual > Visual mode selection

  • How can we select in $Visual$ mode? <

  | Command  | Description                              | <
  | -------- | ---------------------------------------- |
  | ${motion}$ | ^change^ %current end% of $visual selection$   | <
  | $o$        | ^select^ the %other end% of $visual selection$ | <

# Visual > More Visual mode

  • What we can do in $Visual$ mode? <

  | Command | Description     | <
  | ------- | --------------- |
  | $d$       | ^delete^ selected | <
  | $y$       | ^yank^ selected   | <
  | $c$       | ^change^ selected | <
  | $I$       | ^insert^ %before%   | <
  | $A$       | ^append^ %after%    | <

  • $^Operator^ + %Motions%$ is typically favorable over $Visual selection$ <

# Command-line > Ex Command

  • Use $:$ to initiate the command and $<CR>$ to execute <

  | Command      | Description   | <
  | ------------ | ------------- |
  | $:$%{cmd}%       | ^enter^ $command$ | <
  | $:e$dit {file} | ^edit^ $file$     | <
  | $:w$rite       | ^write^ to $file$ | <
  | $:so$urce      | ^source^ $script$ | <

# Command-line > Ex Command History

  • Quickly access to command history <

  | Command      | Description                                       | <
  | ------------ | ------------------------------------------------- |
  | $:$%{cmd}%$<UP>$   | ^complete^ %previous matched% $command$ on $prefix$       | <
  | $:$%{cmd}%$<DOWN>$ | ^complete^ %next matched% $command$ on $prefix$           | <
  | $:$%{cmd}%$<C-p>$  | ^complete^ %previous% $command$                         | <
  | $:$%{cmd}%$<C-n>$  | ^complete^ %next% $command$                             | <
  | $q:$           | ^show^ $command-line window$                          | <
  | $<C-f>$        | ^show^ $command-line window$ (from command-line mode) | <

# Command-line > Ex Command for editing

  • Ex commands for editing <

  | Command                             | Description                          | <
  | ----------------------------------- | ------------------------------------ |
  | $:$[%range%]$d$elete[$reg$]                 | ^delete^ %range% to $reg$                  | <
  | $:$[%range%]$y$ank[$reg$]                   | ^yank^ %range% to $reg$                    | <
  | $:$[%line%]$pu$t[$reg$]                     | ^put^ $reg$ after %line%                   | <
  | $:$[%range%]$co$py {$line$}                 | ^copy^ %range% after $line$                | <
  | $:$[%range%]$t$ {$line$}                    | ^copy^ %range% after $line$                | <
  | $:$[%range%]$m$ove {$line$}                 | ^move^ %range% after $line$                | <
  | $:$[%range%]$j$oin                        | ^join^ $lines$ in %range%                  | <
  | $:norm$al[%!%] {$cmd$}                    | ^run^ normal command                   | <
  | $:$[%range%]$s$ubstitute/$pattern$/new/[gc] | ^substitute^ in %range% matching $pattern$ | <
  | $:$[%range%]$g$lobal/$pattern$/[$cmd$]        | ^run^ $cmd$ in %range% matching $pattern$    | <

# Command-line > Ex Command range

  • What is a $range$ ? <

  | Command           | Description           | <
  | ----------------- | --------------------- |
  | $:%n%$                | $line$ %n%                | <
  | $:+%n%$               | the %next nth% $line$     | <
  | $:-%n%$               | the %previous nth% $line$ | <
  | $:.$                | %current% $line$          | <
  | $:^$                | %first% $line$            | <
  | $:$$                | %last% $line$             | <
  | $:${%start%}$,${%end%}    | from %start% to %end%     | <
  | $:%/{/+1%,%/}/-1%${%cmd%} | use %search% and %offset% | <

# Command-line > Ex Command shell

  • Running shell in Vim is handy <

  | Command         | Description                        | <
  | --------------- | ---------------------------------- |
  | $:!${$cmd$}         | ^run^ $shell cmd$                      | <
  | $:!python %$      | ^run^ $python$ with current file       | <
  | $:$[%range%]$r!${$cmd$} | ^run^ $cmd$ and insert output to %range% | <

# Repeat > The . Command

  • $.$ can ^repeat^ last change <
  • $.$ can use $count$ <
  • $.$ does %not% repeat command-line command <
  • Idealy a change should be $Count$ + ^Operator^ + %Motion% <

# Repeat > The . Command example

  • delete word in sentence: This is no$t$ a test <
    => $dbxx$ <
    => $bdw$ <
    => $daw$ <

# Repeat > Macro

  • Macro records all keystrokes in register and replay <

  | Command    | Description            | <
  | ---------- | ---------------------- |
  | $q${$reg$}     | ^start^ record to $reg$    | <
  | $q$          | ^stop^ record            | <
  | $:reg$isters | ^show^ $registers$         | <
  | [n]$@${$reg$}  | ^replay^ macro in $reg$    | <
  | [n]$@@$      | ^replay^ %previous% macro  | <
  | [n]$@:$      | ^replay^ %last% $Ex command$ | <


# Thanks

{{{ascii
 QQQ   U   U EEEE  SSS  TTTTTT III  OOO  N   N  SSS   ???
Q   Q  U   U E    S       TT    I  O   O NN  N S     ?   ?
Q   Q  U   U EEE   SSS    TT    I  O   O N N N  SSS     ?
Q  QQ  U   U E        S   TT    I  O   O N  NN     S   ?
 QQQQ   UUU  EEEE SSSS    TT   III  OOO  N   N SSSS    ?
     Q
}}}
