$MASTER VIM THE PRACTICAL WAY$

- Bin

# About

  • Covers Vim essentials <
  • Covers more advanced Vim <
  • Covers many useful tips <
  • Helps you to be a Vim master <
  • Does NOT make you a Vim master (Practice!) <
  • Covers only small portion of Vim's power <
  • Vim is just one part of the flow <


# What is Vim?

{{{ascii
TTTTTT EEEE X   X TTTTTT     EEEE DDD  III TTTTTT  OOO  RRRR
  TT   E     X X    TT       E    D  D  I    TT   O   O R   R
  TT   EEE    X     TT       EEE  D  D  I    TT   O   O RRRR
  TT   E     X X    TT       E    D  D  I    TT   O   O R R
  TT   EEEE X   X   TT       EEEE DDD  III   TT    OOO  R  RR
}}}

# Why Vim?

  ## Efficiency <
    • No mouse
    • No ambiguity
    • Powerful modal editing
    • Designed for DRY (_Don't Repeat Yourself_)

  ## Performance <
    • Fast
    • Lightweight

  ## Customization <
    • Config
    • Plugin
    • Script
    • Integration

  ## Documentation <
    • Comprehensive builtin documentation

# How to Start?

  ## Touch Typing <
    • The foundation <
    • Practice more for numbers and special characters

  ## Vimtutor <
    • $ vimtutor <

  ## Minimal Config <
    • Minimal %.vimrc% config to start with

    {{{vim " .vimrc
    set nocompatible
    syntax on
    filetype plugin indent on }}}

# How to Start?

  ## Use Docker Image <
    • Install [Docker for Mac](https://download.docker.com/mac/stable/Docker.dmg) <
    • Run $docker run -it --rm soweyln/vim$ <
      ▸ Run $vim -u vimrc.min$ to use minimal config <
      ▸ Run $vim$ to use full config <

# How to Start?

  • The very $essential commands$ to get started <

  | Command          | Description                                 | <
  | ---------------- | ------------------------------------------- |
  | $h$, $j$, $k$, $l$       | ^move^ %left%, %down%, %up%, %right%                  | <
  | :w               | ^write^ to $file$                               | <
  | :q               | ^quit^ $window$                                 | <
  | :q!              | ^quit^ $window$ (%discard changes%)               | <
  | :e {file}        | ^edit^ $file$ in window                         | <
  | :e {dir}         | ^open^ $dir$ in file browser                    | <
  | $w$                | ^move^ to the %next% $start of word$              | <
  | $b$                | ^move^ to the %previous% $start of word$          | <
  | $$$                | ^move^ to the $end of line$                     | <
  | $0$                | ^move^ to the $beginning of line$               | <
  | $gg$               | ^move^ to the $first line$                      | <
  | $G$                | ^move^ to the $last line$                       | <
  | [%n%]$gg$            | ^move^ to $line$ %n%                              | <
  | $<C-d>$            | ^move^ $half page$ %down%                         | <
  | $<C-u>$            | ^move^ $half page$ %up%                           | <
  | $i$                | ^insert^ %before%                               | <
  | $a$                | ^append^ %after%                                | <
  | $<ESC>$            | ^return^ to $Normal$ mode                       | <
  | $dd$               | ^delete^ $current line$                         | <
  | $dw$               | ^delete^ %until next% $start of word$ (exclusive) | <
  | $u$                | ^undo^ $last edit$                              | <
  | $<C-r>$            | ^redo^ $last edit$                              | <
  | $yy$               | ^yank^ $current line$                           | <
  | $p$                | ^paste^ %after%                                 | <
  | $/${pattern}$<CR>$   | ^search^ %forward% for ${pattern}$                | <
  | $:%s$/old/new/[gc] | ^substitute^ in $buffer$                        | <

# How to Start?

  ## Use Help <

  | Command           | Description                             | <
  | ----------------- | --------------------------------------- |
  | $:h$elp             | ^open^ $help$                               | <
  | $:h$elp {$topic$}     | ^open^ $help$ for $topic$                     | <
  | $<C-]>$             | ^jump^ to $tag$                             | <
  | $<C-o>$             | ^jump^ %back%                               | <
  | $:helpg$rep {$topic$} | ^search^ $help$ for $topic$                   | <
  | $:h$elp $x$           | ^open^ $help$ for $x$ in %Normal% mode          | <
  | $:h$elp $v_x$         | ^open^ $help$ for $x$ in %Visual% mode          | <
  | $:h$elp $i_x$         | ^open^ $help$ for $x$ in %Insert% mode          | <
  | $:h$elp $:x$          | ^open^ $help$ for $x$ in %Command-line% mode    | <
  | $:h$elp $c_x$         | ^open^ $help$ for $x$ in %Command-line% editing | <
  | $:h$elp $-x$          | ^open^ $help$ for $x$ for %Command Argument%    | <
  | $:h$elp $'x'$         | ^open^ $help$ for $x$ for %Option%              | <
  | $:h$elp $/x$          | ^open^ $help$ for $x$ for %Regex%               | <
  | $:helpt$ags {$dir$}   | ^generate^ $help tags$ for $dir$              | <

  • Be sure to check out $:h help-context$ and $:h help-summary$ <
  • Use $<Tab>$ to autocomplete <

# Key Takeaways

  • $Count + Operator + Motion$ <

  • $Don't Repeat Yourself$ <

  • $Customize + Scripting$ <

# Contents

  • Modes
  • Move
  • Edit
  • Visual
  • Command
  • Repeat
  • Search
  • Files
  • Thanks

# Modes

  • Normal <
  • Insert <
  • Command-line <
  • Visual <
  • Operator-pending <
  • Replace <

# Modes > Switch between Modes

  • Vim is in $Normal$ mode when it launches. <
  • We can switch between different modes <

  | Command                    | Description                     | <
  | -------------------------- | ------------------------------- |
  | Normal + $a,A,C,i,I,o,O,s,S$ | ^switch^ to $Insert$ mode           | <
  | Normal + $:,/,?$             | ^switch^ to $Command-line$ mode     | <
  | Normal + $v,V,<C-v>$         | ^switch^ to $Visual$ mode           | <
  | Normal + $c,d,y$             | ^switch^ to $Operator-pending$ mode | <
  | Normal + $R$                 | ^switch^ to $Replace$ mode          | <
  | ANY + $<ESC>$                | ^switch^ to $Normal$ mode           | <

# Move

  • Moving around is one $crucial$ part of the flow when using Vim <
  • ^Avoid^ using $arrow keys$ to move <
  • ^Avoid^ move in $Insert$ mode <
  • Better to ^avoid^ using %repeated% $h/j/k/l$ to move <
  • Most moves can be ^repeated^ by $count$ <

# Move > Move by direction

  • $h/j/k/l$ can be repeated by $count$ <

  | Command | Description               | <
  | ------- | ------------------------- |
  | [%n%]$h$    | ^move^ %n% $character(s)$ %left%  | <
  | [%n%]$j$    | ^move^ %n% $line(s)$ %down%       | <
  | [%n%]$k$    | ^move^ %n% $line(s)$ %up%         | <
  | [%n%]$l$    | ^move^ %n% $character(s)$ %right% | <

# Move > Move by word

  • A $word$ is a sequence of letters, digits, understores or other non-blank characters. <
  • It can be customized with $iskeyword$.
  • Move by $word$ is useful and much faster than move by single character.

  | Command | Description                            | <
  | ------- | -------------------------------------- |
  | [%n%]$w$    | ^move^ to the %nth next% $start of word$     | <
  | [%n%]$b$    | ^move^ to the %nth previous% $start of word$ | <
  | [%n%]$e$    | ^move^ to the %nth next% $end of word$       | <
  | [%n%]$ge$   | ^move^ to the %nth previous% $end of word$   | <

# Move > Move by WORD

  • A $WORD$ is a sequence of $non-blank characters$ separated by white space. <
  • Move by $WORD$ is preferred in certain cases.

  | Command | Description                            | <
  | ------- | -------------------------------------- |
  | [%n%]$W$    | ^move^ to the %nth next% $start of WORD$     | <
  | [%n%]$B$    | ^move^ to the %nth previous% $start of WORD$ | <
  | [%n%]$E$    | ^move^ to the %nth next% $end of WORD$       | <
  | [%n%]$gE$   | ^move^ to the %nth previous% $end of WORD$   | <

# Move > Move in line by line boundary

  • Move using $$$, $0$, $^$ is a quicker way to navigate to / between ends of current line. <

  | Command | Description                                               | <
  | ------- | --------------------------------------------------------- |
  | $0$       | ^move^ to the $beginning$ of line                             | <
  | $^$       | ^move^ to the $first non-blank character$ of line             | <
  | [%n%]$$$    | ^move^ to the $end$ of %(n-1)th next% line                      | <
  | [%n%]$g_$   | ^move^ to the $last non-blank character$ of %(n-1)th next% line | <

# Move > Move in line by finding character

  • Move using $f$, $t$ is a more precise way. <
  • Be aware of the $choice$ of {c}.

  | Command | Description                                                      | <
  | ------- | ---------------------------------------------------------------- |
  | [%n%]$f{c}$ | ^move^ %to% the %nth next% $occurrence of {c}$ in line                   | <
  | [%n%]$t{c}$ | ^move^ %till% the %nth next% $occurrence of {c}$ in line (exclusive)     | <
  | [%n%]$F{c}$ | ^move^ %to% the %nth previous% $occurrence of {c}$ in line               | <
  | [%n%]$T{c}$ | ^move^ %till% the %nth previous% $occurrence of {c}$ in line (exclusive) | <
  | [%n%]$;$    | ^repeat^ $last find$ %n times% in line                                 | <
  | [%n%]$,$    | ^repeat^ $last find$ %n times% in line in %opposite direction%           | <

# Move > Cursor and Window

  • $Cursor$ position vs $Window$ position <
  • Vim always make sure cursor is %inside% window <
  • The window position depends on $scrolloff$ config <

# Move > Move by line

  • Use $gg$ or $G$ to move to line <

  | Command | Description            | <
  | ------- | ---------------------- |
  | $gg$      | ^move^ to the $first line$ | <
  | $G$       | ^move^ to the $last line$  | <
  | [%n%]$gg$   | ^move^ to $line$ %n%       | <
  | [%n%]$G$    | ^move^ to $line$ %n%       | <

# Move > Move by page

  • Move faster by $page$ <
  • More useful to $navigate$ rather than position
  • Harder to foresee the exact position

  | Command | Description                           | <
  | ------- | ------------------------------------- |
  | $<C-d>$   | ^move^ $cursor$ %half page down%            | <
  | $<C-u>$   | ^move^ $cursor$ %half page up%              | <
  | $<C-f>$   | ^move^ $window$ %one page down%             | <
  | $<C-b>$   | ^move^ $window$ %one page up%               | <
  | $H$       | ^move^ $cursor$ to %"first line"% in $window$ | <
  | $M$       | ^move^ $cursor$ to %middle line% in $window$  | <
  | $L$       | ^move^ $cursor$ to %"last line"% in $window$  | <

# Move > Move by object

  • Move by $sentence$ and $paragraph$ <

  | Command | Description                                 | <
  | ------- | ------------------------------------------- |
  | [%n%]$($    | ^move^ to the %beginning% of %previous% $sentence$  | <
  | [%n%]$)$    | ^move^ to the %beginning% of %next% $sentence$      | <
  | [%n%]${$    | ^move^ to the %beginning% of %previous% $paragraph$ | <
  | [%n%]$}$    | ^move^ to the %beginning% of %next% $paragraph$     | <

# Move > Move by search

  • We can also use pattern $search$ to move around <
  • More in $Search$ section

  | Command        | Description                           | <
  | -------------- | ------------------------------------- |
  | $*$              | ^search^ %forward% for $word under cursor$  | <
  | $#$              | ^search^ %backward% for $word under cursor$ | <
  | $/${pattern}$<CR>$ | ^search^ %forward% for ${pattern}$          | <
  | $?${pattern}$<CR>$ | ^search^ %backward% for pattern ${pattern}$ | <
  | $n$              | ^move^ to the %next% $match$                | <
  | $N$              | ^move^ to the %previous% $match$            | <

# Move > Move by match

  • We can also move around using $([{$ semantics <

  | Command | Description                                                | <
  | ------- | ---------------------------------------------------------- |
  | $%$       | ^find^ $([{ in line$ and ^move^ to the $matching close$            | <
  | $[{$      | ^go^ to %previous% $unmatched {$ (%beginning% of $outer code block$) | <
  | $]}$      | ^go^ to %next% $unmatched }$ (%end% of $outer code block$)           | <
  | $[($      | ^go^ to %previous% $unmatched ($ (%beginning% of $outer func param$) | <
  | $])$      | ^go^ to %next% $unmatched )$ (%end% of $outer func param$)           | <

# Move > Move by mark

  • Mark is useful for $remember$ a location <
  • Take advantage of $special marks$

  | Command | Description                             | <
  | ------- | --------------------------------------- |
  | $m${mark} | ^add^ a $mark$                              | <
  | $`${mark} | ^goto^ a $mark$ (%exact position%)            | <
  | $'${mark} | ^goto^ a $mark$ (%first non-blank character%) | <

  | Marks | Description                              | <
  | ----- | ---------------------------------------- |
  | ${a-z}$ | $local$ mark in buffer                     | <
  | ${A-Z}$ | $global$ mark                              | <
  | $.$     | $last edited$                              | <
  | $'$     | $latest jump$                              | <
  | $`$     | $latest jump$                              | <
  | $"$     | $last position$ before leave buffer        | <
  | $^$     | $last insert$ position                     | <
  | $[$     | %beginning% of $last changed or yanked$ text | <
  | $]$     | %end% of $last changed or yanked$ text       | <
  | $<$     | %beginning% of $last visual select$          | <
  | $>$     | %end% of $last visual select$                | <

# Move > Move by jumps

  • $jumplist$ maintains jumps history, we can use it to jump back and forth <

  | Command | Description                        | <
  | ------- | ---------------------------------- |
  | $<C-o>$   | ^jump^ to %older% position in $jumplist$ | <
  | $<C-i>$   | ^jump^ to %newer% position in $jumplist$ | <
  | $:jumps$  | ^list^ $jumps history$                 | <

# Move > Move by changes

  • $changelist$ maintains changes history, we can use it to jump back and forth as well <

  | Command  | Description                          | <
  | -------- | ------------------------------------ |
  | $g;$       | ^jump^ to %older% position in $changelist$ | <
  | $g,$       | ^jump^ to %newer% position in $changelist$ | <
  | $gi$       | ^insert^ at $last insert position$       | <
  | $:changes$ | ^list^ $changes history$                 | <

# Edit > Edit in Normal mode

  • Basic commands to edit text in $Normal$ mode only <

  | Command        | Description                        | <
  | -------------- | ---------------------------------- |
  | [%n%]$x$           | ^delete^ $current character$           | <
  | [%n%]$r${c}        | ^replace^ $current character$ with %{c}% | <
  | [%n%]$dd$          | ^delete^ $current line$                | <
  | [%n%]$D$           | ^delete^ to $end of current line$      | <
  | [%n%]$d${%motion%}   | ^delete^ using %motion%                | <
  | [%n%]$J$           | ^join^ $lines$                         | <

# Edit > Enter Insert mode

  • There are various ways to ^enter^ $Insert$ mode <
  • Many of them have additional move benefits.

  | Command | Description                             | <
  | ------- | --------------------------------------- |
  | $a$       | ^append^ %after% $cursor$                     | <
  | $A$       | ^append^ %after% $end of line$                | <
  | $i$       | ^insert^ %before% $cursor$                    | <
  | $I$       | ^insert^ %before% $first non-blank character$ | <
  | $o$       | ^insert^ %below% $line$                       | <
  | $O$       | ^insert^ %above% $line$                       | <
  | $s$       | ^change^ %current% $character$                | <
  | $C$       | ^change^ %current% $line$                     | <
  | $cc$      | ^change^ %current% $line$                     | <

# Edit > Edit in Insert mode

  • There are various ways to ^edit^ in $Insert$ mode <

  | Command        | Description                                  | <
  | -------------- | -------------------------------------------- |
  | $typing$         | ^typing^ to edit                               | <
  | $<BS>$           | ^delete^ %left%                                  | <
  | $<DEL>$          | ^delete^ %right%                                 | <
  | $<C-w>$          | ^delete^ %left% $a word$                           | <
  | $<C-u>$          | ^delete^ %left to% $first non-blank word$          | <
  | $<C-r>${reg}     | ^insert^ $register {reg}$                      | <
  | $<C-r>=$         | ^insert^ $eval result of an expression$          | <
  | $<C-v>${c}       | ^insert^ ${c}$ %literally%                         | <
  | $<C-k>${digraph} | ^insert^ ${digraph}$                             | <
  | $<C-o>$          | ^run^ $a Normal command$ and ^back^ to $Insert$ mode | <

# Edit > Count + Operator + Motion

  $Count$ + ^Operator^ + %Motion% <
  • $Count$: an arbitrary number (_how many_) <
  • ^Operator^: an action (_what_) <
  • %Motion%: a descriptive (_where_) <

# Edit > Operator

  • ^Operator^: an action (_what to do_) <

  | Command | Description  | <
  | ------- | ------------ |
  | $c$       | ^change^       | <
  | $d$       | ^delete^       | <
  | $y$       | ^yank^         | <
  | $=$       | ^auto indent^  | <
  | $>$       | ^indent^ %right% | <
  | $<$       | ^indent^ %left%  | <
  | $~$       | ^swap case^    | <
  | $gu$      | ^lower case^   | <
  | $gU$      | ^upper case^   | <

# Edit > Motion

  • %Motion%: a descriptive (_where_) <
    ◦ $All move commands$ mentioned before (_almost_) <
    ◦ $Text Object$ <

# Edit > Text Object

  • $Selection Mode$ <
    ◦ $i$: %inside% (exclusive)
    ◦ $a$: %around% (inclusive)

  • $Text Objects$ <

    | Command | Description    | <
    | ------- | -------------- |
    | $w$       | $word$           | <
    | $W$       | $WORD$           | <
    | $s$       | $sentence$       | <
    | $p$       | $paragraph$      | <
    | $t$       | $xml tag$        | <
    | $'$       | $single quotes$  | <
    | $"$       | $double quotes$  | <
    | $`$       | $backticks$      | <
    | $[$,$]$     | $brackets$       | <
    | $($,$)$     | $parentheses$    | <
    | ${$,$}$     | $braces$         | <
    | $<$,$>$     | $angle brackets$ | <

  • $Custom Text Objects$ <

# Edit > Count + Operator + Motion

  $Count$ + ^Operator^ + %Motion% <

  • It is an atomic action and can be repeated using $.$ command <
  • Let's see some examples <

  | Command | Description             | <
  | ------- | ----------------------- |
  | $daw$     | ^delete^ %around% $word$      | <
  | $dap$     | ^delete^ %around% $paragraph$ | <
  | $cib$     | ^change^ %inside% $()$        | <
  | $cit$     | ^change^ %inside% $tag$       | <
  | $ct,$     | ^change^ %until% $,$          | <
  | $yaB$     | ^yank^ %around% ${}$          | <

# Edit > Registers

  • Registers are the enhanced "clipboards" in Vim <

  | Register | Description               | <
  | -------- | ------------------------- |
  | $"$        | %unnamed% (any last change) | <
  | $0$        | %yank%                      | <
  | $1$-$9$      | %delete% (1 is the newest)  | <
  | ${a-z}$    | %named% $register$ (replace)  | <
  | ${A-Z}$    | %named% $register$ (append)   | <
  | $%$        | %current file%              | <
  | $#$        | %alternative file%          | <
  | $:$        | %last ex command%           | <
  | $/$        | %last search%               | <
  | $+$        | %system clipboard%          | <
  | $*$        | %primary clipboard%         | <
  | $.$        | %last inserted text%        | <
  | $=$        | %expression%                | <
  | $-$        | %small change% (in a line)  | <

# Edit > Registers

  • How to use registers <

  | Command         | Description                                         | <
  | --------------- | --------------------------------------------------- |
  | $"${reg}$y${%motion%} | ^set^ $register {reg}$                                  | <
  | $"${reg}$p$         | ^put^ $register {reg}$                                  | <
  | $:reg$isters      | ^show^ $registers$                                      | <
  | $<C-r>${reg}      | ^insert^ $register {reg}$ (in $Insert$/$Command-line$ mode) | <
  | $@${reg}          | ^insert^ $register {reg}$ in eval mode                  | <

# Edit > Yank & Put

  • Yank is "Copy" in Vim <
  • Put is "Paste" in Vim

  | Command           | Description               | <
  | ----------------- | ------------------------- |
  | [%n%]$yy$             | ^yank^ $line(s)$              | <
  | [%n%]$Y$              | ^yank^ $line(s)$              | <
  | [$"{reg}$]$y${%motion%} | ^yank^ to $register {reg}$    | <
  | [$"{reg}$]$p$         | ^put^ $register {reg}$ %after%  | <
  | [$"{reg}$]$P$         | ^put^ $register {reg}$ %before% | <

# Edit > Yank & Put use cases

  • $xp$ <
    => ^swap^ $character$ <

  • $ddp$ <
    => ^swap^ $line$ <

  • $yyp$ <
    => ^duplicate^ $line$ <

  • swap two adjacent words? <
    => $dwwhp$ <
    => $dww^P^$ <
    => $d^e^wP^ldebh^P$ <
    => $de^mm^wPlde^`m^P$ <
    => $d^iw^mmwPlde`mP$ <

# Edit > Undo & Redo

  • Undo and Redo (revert undo) is common, but Vim gives us a more sophisticated one. <

  | Command  | Description                       | <
  | -------- | --------------------------------- |
  | [%n%]$u$     | ^undo^ $change(s)$                    | <
  | [%n%]$<C-r>$ | ^redo^ $changes(s)$                   | <
  | $U$        | ^undo^ $all latest changes in a line$ | <

# Edit > Undo Branchs

  • Undos can $branch$ off <
  • We can undo by time sequence <

  | Command               | Description                                 | <
  | --------------------- | ------------------------------------------- |
  | [%n%]$g-$                 | ^go to^ %older% $state$                           | <
  | [%n%]$g+$                 | ^go to^ %newer% $state$                           | <
  | $:ea$rlier {%n%}          | ^go to^ %older% $state$                           | <
  | $:ea$rlier {%n%}%s/m/h/d/f% | ^go to^ %older% $state$ about certain time %before% | <
  | $:lat$er {%n%}            | ^go to^ %newer% $state$                           | <
  | $:lat$er {%n%}%s/m/h/d/f%   | ^go to^ %newer% $state$ about certain time %after%  | <

# Visual > Enter Visual mode

  • There are three ways to enter slightly different $Visual$ mode <

  | Command | Description                      | <
  | ------- | -------------------------------- |
  | $v$       | ^switch to^ %normal% $Visual$ mode     | <
  | $V$       | ^switch to^ %line-wise% $Visual$ mode  | <
  | $<C-v>$   | ^switch to^ %block-wise% $Visual$ mode | <

  • These commands can be used to ^switch^ between different modes as well <

  • We can ^reselect^ the $last visual selection$ using $gv$ <

# Visual > Visual mode selection

  • How can we select in $Visual$ mode? <

  | Command  | Description                              | <
  | -------- | ---------------------------------------- |
  | ${motion}$ | ^change^ %current end% of $visual selection$   | <
  | $o$        | ^select^ the %other end% of $visual selection$ | <

# Visual > More Visual mode

  • What we can do in $Visual$ mode? <

  | Command | Description     | <
  | ------- | --------------- |
  | $d$       | ^delete^ selected | <
  | $y$       | ^yank^ selected   | <
  | $c$       | ^change^ selected | <
  | $I$       | ^insert^ %before%   | <
  | $A$       | ^append^ %after%    | <

  • $^Operator^ + %Motions%$ is typically favorable over $Visual selection$ <

# Command-line > Ex Command

  • Use $:$ to initiate the command and $<CR>$ to execute <

  | Command      | Description   | <
  | ------------ | ------------- |
  | $:$%{cmd}%       | ^enter^ $command$ | <
  | $:e$dit {file} | ^edit^ $file$     | <
  | $:w$rite       | ^write^ to $file$ | <
  | $:so$urce      | ^source^ $script$ | <

# Command-line > Ex Command History

  • Quickly access to command history <

  | Command      | Description                                       | <
  | ------------ | ------------------------------------------------- |
  | $:$%{cmd}%$<UP>$   | ^complete^ %previous matched% $command$ on $prefix$       | <
  | $:$%{cmd}%$<DOWN>$ | ^complete^ %next matched% $command$ on $prefix$           | <
  | $:$%{cmd}%$<C-p>$  | ^complete^ %previous% $command$                         | <
  | $:$%{cmd}%$<C-n>$  | ^complete^ %next% $command$                             | <
  | $q:$           | ^show^ $command-line window$                          | <
  | $<C-f>$        | ^show^ $command-line window$ (from command-line mode) | <

# Command-line > Ex Command for editing

  • Ex commands for editing <

  | Command                             | Description                          | <
  | ----------------------------------- | ------------------------------------ |
  | $:$[%range%]$d$elete[$reg$]                 | ^delete^ %range% to $reg$                  | <
  | $:$[%range%]$y$ank[$reg$]                   | ^yank^ %range% to $reg$                    | <
  | $:$[%line%]$pu$t[$reg$]                     | ^put^ $reg$ after %line%                   | <
  | $:$[%range%]$co$py {$line$}                 | ^copy^ %range% after $line$                | <
  | $:$[%range%]$t$ {$line$}                    | ^copy^ %range% after $line$                | <
  | $:$[%range%]$m$ove {$line$}                 | ^move^ %range% after $line$                | <
  | $:$[%range%]$j$oin                        | ^join^ $lines$ in %range%                  | <
  | $:norm$al[%!%] {$cmd$}                    | ^run^ normal command                   | <
  | $:$[%range%]$s$ubstitute/$pattern$/new/[gc] | ^substitute^ in %range% matching $pattern$ | <
  | $:$[%range%]$g$lobal/$pattern$/[$cmd$]        | ^run^ $cmd$ in %range% matching $pattern$    | <

# Command-line > Ex Command range

  • What is a $range$ ? <

  | Command           | Description           | <
  | ----------------- | --------------------- |
  | $:%n%$                | $line$ %n%                | <
  | $:+%n%$               | the %next nth% $line$     | <
  | $:-%n%$               | the %previous nth% $line$ | <
  | $:.$                | %current% $line$          | <
  | $:^$                | %first% $line$            | <
  | $:$$                | %last% $line$             | <
  | $:${%start%}$,${%end%}    | from %start% to %end%     | <
  | $:%/{/+1%,%/}/-1%${%cmd%} | use %search% and %offset% | <

# Command-line > Ex Command shell

  • Running shell in Vim is handy <

  | Command         | Description                        | <
  | --------------- | ---------------------------------- |
  | $:!${$cmd$}         | ^run^ $shell cmd$                      | <
  | $:!python %$      | ^run^ $python$ with current file       | <
  | $:$[%range%]$r!${$cmd$} | ^run^ $cmd$ and insert output to %range% | <

# Repeat > The . Command

  • $.$ can ^repeat^ last change <
  • $.$ can use $count$ <
  • $.$ does %not% repeat command-line command <
  • Idealy a change should be $Count$ + ^Operator^ + %Motion% <

# Repeat > The . Command example

  • delete word in sentence: This is no$t$ a test <
    => $dbxx$ <
    => $bdw$ <
    => $daw$ <

# Repeat > Macro

  • Macro records all keystrokes in register and replay <

  | Command    | Description            | <
  | ---------- | ---------------------- |
  | $q${$reg$}     | ^start^ record to $reg$    | <
  | $q$          | ^stop^ record            | <
  | $:reg$isters | ^show^ $registers$         | <
  | [%n%]$@${$reg$}  | ^replay^ macro in $reg$    | <
  | [%n%]$@@$      | ^replay^ %previous% macro  | <
  | [%n%]$@:$      | ^replay^ %last% $Ex command$ | <

# Repeat > Code Clinic

  • Append ; to non-blank lines? <
    ◦ $$$$a;$ => $.$ <
    ◦ $A;$ => $.$ <
    ◦ $qaA;<ESC>j$ => $[n]@a$ <
    ◦ $$$$<C-v>[n]jA;$ <

# Search > Search in buffer

  • Recap <

  | Command        | Description                           | <
  | -------------- | ------------------------------------- |
  | $*$              | ^search^ %forward% for $word under cursor$  | <
  | $#$              | ^search^ %backward% for $word under cursor$ | <
  | $/${pattern}$<CR>$ | ^search^ %forward% for ${pattern}$          | <
  | $?${pattern}$<CR>$ | ^search^ %backward% for pattern ${pattern}$ | <
  | $n$              | ^move^ to the %next% $match$                | <
  | $N$              | ^move^ to the %previous% $match$            | <

# Search > Search in buffer

  • More search <

  | Command        | Description                                            | <
  | -------------- | ------------------------------------------------------ |
  | $g*$             | ^search^ %forward% for $word under cursor$ without boundary  | <
  | $g#$             | ^search^ %backward% for $word under cursor$ without boundary | <
  | $/<CR>$          | ^repeat^ %last% $search$ (pattern only)                      | <
  | $gn$             | ^repeat^ %last% $search$ %forward% and ^select^ $match$ in visual  | <
  | $gN$             | ^repeat^ %last% $search$ %backward% and ^select^ $match$ in visual | <
  | $:noh$lsearch    | ^hide^ $highlight$ once                                    | <
  | $:set incsearch$ | ^show^ $highlight$ when typing                             | <
  | $q/$             | ^show^ $search history$                                    | <

# Search > Search mode

  • $magic$ (default) <
  • $very magic$ (matching character without backslash) <
  • $very nomagic$ (matching character literally) <

  | Command | Description       | <
  | ------- | ----------------- |
  | $\v$      | very magic mode   | <
  | $\V$      | very nomagic mode | <

# Search > Search mode example

  • $#AA0BB1 or #AA0$ <
    => /#\([0-9a-fA-F]\{6}\|[0-9a-fA-F]\{3}\) <
    => /\v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3}) <
    => /\v#(\x{6}|\x{3}) <

  • $a.k.a.$ but not $backward$ <
    => /a\.k\.a\. <
    => /\Va.k.a. <

# Search > Offset

  • We can add offset to search option <
  • $/${pattern}/{%offset%}$<CR>$ <

  | Option             | Description                                  | <
  | ------------------ | -------------------------------------------- |
  | ${n}$, $+{n}$, $-{n}$    | ^offset^ by $line$ (watch out for infinite loop) | <
  | $b{n}$, $b+{n}$, $b-{n}$ | ^offset^ relative to the %beginning% of $match$    | <
  | $s{n}$, $s+{n}$, $s-{n}$ | ^offset^ relative to the %start% of $match$        | <
  | $e{n}$, $e+{n}$, $e-{n}$ | ^offset^ relative to the %end% of $match$          | <
  | $;$                  | ^offset^ by $another search$                     | <

# Search > Case match

  • Config level case match <
  • Match level case match override <

  | Option     | Description                                  | <
  | ---------- | -------------------------------------------- |
  | $ignorecase$ | ^ignore^ case                                  | <
  | $smartcase$  | ^use^ %smart% case                               | <
  | $\c$         | ^ignore^ case (override ignorecase, smartcase) | <
  | $\C$         | ^match^ case (override ignorecase, smartcase)  | <

# Search > Match boundary

  • Sometimes we want to match the whole pattern but only interested in part of it <

  | Option | Description        | <
  | ------ | ------------------ |
  | $\zs$    | ^set^ %start% of $match$ | <
  | $\ze$    | ^set^ %end% of $match$   | <

  • $match string content only$ <
    => /\v"\zs[^"]*\ze" <

# Search > Multiple lines

  • Sometimes we do want to match multiple lines <

  | Option | Description               | <
  | ------ | ------------------------- |
  | $\_${c}  | pattern {c} + %end% of $line$ | <

  • $match multi-line string$ <
    => /\v"\_[^"]*" <

# Search > Capture match

  • Sometimes we want capture the match to use it for further purpose <

  | Option | Description               | <
  | ------ | ------------------------- |
  | $()$     | ^capture^ match group       | <
  | $%()$    | ^avoid capture^ match group | <

  • $match any repeated words$ <
    ◦ test test <
    => /test test <
    ◦ test   test <
    => /%\v%test%\s+%test <
    ◦ multiline <
    => /\vtest(%\n%|\s)+test <
    => /\vtest%\_s%+test <
    ◦ atest testb <
    => /\v%<%test\_s+test%>% <
    ◦ test2 test2 <
    => /\v<%(\w+)%\_s+%\1%> <
    ◦ test test test <
    => /\v<(\w+)%(%\_s+\1>%)+% <

# Search > Substitute

  • On top of search, we can do substitute <

  | Command                         | Description                                       | <
  | ------------------------------- | ------------------------------------------------- |
  | $:$[%range%]$s$ubstitute/old/new/[%gc%] | ^substitute^ in $buffer$                                | <
  | $:s$,$:&$,$&$                         | ^repeat^ last $substitute$ %without% options            | <
  | $:&&$                             | ^repeat^ last $substitute$ %with% options               | <
  | $g&$                              | ^repeat^ last $substitute$ %with% options for $all lines$ | <
  | $:$[%range%]$s$ubstitute//new/[%gc%]    | ^substitute^ reusing $last search pattern$            | <

# Search > Global

  • On top of search, we can do global command <
  • Select lines match with pattern (or negate) and run Ex command <

  | Command                       | Description                           | <
  | ----------------------------- | ------------------------------------- |
  | $:$[%range%]$g$lobal/pattern/[%cmd%]  | ^run^ $cmd$ in %range% matching $pattern$     | <
  | $:$[%range%]$v$lobal/pattern/[%cmd%]  | ^run^ $cmd$ in %range% %NOT% matching $pattern$ | <
  | $:$[%range%]$g!$lobal/pattern/[%cmd%] | ^run^ $cmd$ in %range% %NOT% matching $pattern$ | <

  • %range% by default is $%$
  • %cmd% by default is $p$

  • :g/bad <
    => print all lines contain $bad$ <

  • :g/bad/d <
    => delete all lines contain $bad$ <

  • :g!/good/d <
    => keep all lines contain $good$ <

  • :g/{/.+1,/}/-1sort <
    => sort lines inside matching braces <
    => {{{txt$:g/\v\{$\n\zs\_[^{]{-,}\ze^\s*\}/.+1,/}/-1sort}}}

# Files > File

  | Command        | Description                                   | <
  | -------------- | --------------------------------------------- |
  | $:e$dit {%file%}   | ^edit^ $file$ in window                           | <
  | $:e$dit$!$         | ^read^ $file$ from disk (discard unsaved changes) | <
  | $:w$rite[$!$]      | ^write^ to $file$ (override if using $!$)           | <
  | $:wa$ll[$!$]       | ^write^ all to $file$ (override if using $!$)       | <
  | $:sp$lit {%file%}  | ^edit^ $file$ in %horizontal% split                 | <
  | $:vs$plit {%file%} | ^edit^ $file$ in %vertical% split                   | <

# Files > Window

  | Command               | Description                             | <
  | --------------------- | --------------------------------------- |
  | $<C-w>s$                | ^split^ $window$ %horizontally%               | <
  | $<C-w>v$                | ^split^ $window$ %vertically%                 | <
  | $<C-w>${$h$,$j$,$k$,$l$}        | ^move^ to %left%, %bottom%, %top%, %right% $window$ | <
  | $<C-w>w$                | ^move^ to %next% $window$ (cycle)             | <
  | $<C-w>c$, $:clo$se        | ^close^ %current% $window$                    | <
  | $<C-w>o$, $:on$ly         | ^close^ %all other% $windows$                 | <
  | $<C-w>$[%count%]{$+$,$-$,$<$,$>$} | ^expand/shrink^ %current% $window$            | <

# Files > Tab

  | Command                 | Description                            | <
  | ----------------------- | -------------------------------------- |
  | $:tabe$dit {%file%}         | ^edit^ $file$ in new $tab$                   | <
  | $:tabn$ext [$id$] or [$id$]$gt$ | ^move^ to %next% $tab$ or $id$                 | <
  | $:tabp$revious or $gT$      | ^move^ to %previous% $tab$                   | <
  | $:tabc$lose               | ^close^ %current% $tab$                      | <
  | $:tabo$nly                | ^close^ %all other% $tabs$                   | <
  | $:tabm$ove [$id$]           | ^move^ $tab$ to $id$ (or to the end if omit) | <
  | $<C-w>T$                  | ^move^ %current% $window$ to a $tab$           | <

# Files > File vs Buffer vs Window vs Tab

  ## For most editors
  • File = [Buffer] = [Window] = [Tab]

  ## For Vim
  • $File$ is contents in %disk% (not a focus in Vim) <
  • $Buffer$ is contents in %memory% (used a lot in Vim) <
  • $Window$ is a %viewport%, or a %container% for a $Buffer$
  • $Tab$ is a %group% of $Windows$

# Files > Buffer List

  • Buffer list maintains a list of opened buffers <
  • Tends to be changed easily <

  | Command         | Description                              | <
  | --------------- | ---------------------------------------- |
  | $:ls$, $:buffers$   | ^list^ all $buffers$                         | <
  | $:bn$ext [%n%]      | ^goto^ %n%th %next% $buffer$ in buffer list      | <
  | $:bp$revious [%n%]  | ^goto^ %n%th %previous% $buffer$ in buffer list  | <
  | $:bf$irst         | ^goto^ %first% $buffer$ in buffer list         | <
  | $:bl$alst         | ^goto^ %last% $buffer$ in buffer list          | <
  | $:b$uffer{$id$}     | ^goto^ $buffer$ %id% in buffer list            | <
  | $:bd$elete {$ids$}  | ^delete^ $buffers$ of %ids% in buffer list     | <
  | $:$[%range%]$bd$elete | ^delete^ $buffers$ with %range% in buffer list | <

# Files > Argument List

  • Originated from starting Vim with multiple files <
  • More stable and well defined <
  • Normally a subset of buffer list <

  | Command           | Description                               | <
  | ----------------- | ----------------------------------------- |
  | $vim$ {$pattern$}     | ^open^ Vim with argument list using $pattern$ | <
  | $:ar$gs             | ^list^ argument list                        | <
  | $:ar$gs {$pattern$}   | ^recreate^ argument list using $pattern$      | <
  | $:$[%n%]$arga$dd [$file$] | ^add^ $file$ to argument list after %nth%       | <
  | $:$[%n%]$n$ext          | ^goto^ %nth next% buffer in argument list     | <
  | $:$[%n%]$prev$ious      | ^goto^ %nth previous% buffer in argument list | <
  | $:fir$st            | ^goto^ %first% in argument list               | <
  | $:la$st             | ^goto^ %last% in argument list                | <

# Files > Quickfix List

  • Quickfix list is designed for quickly navigating across different locations <
  • Only $one$ global quickfix list <

  | Command                   | Description                                         | <
  | ------------------------- | --------------------------------------------------- |
  | $:vim$grep {$pattern$} {$file$} | ^search^ for $pattern$ in $file$ and ^add^ to quickfix list | <
  | $:cope$n                    | ^open^ quickfix list                                  | <
  | $:ccl$ose                   | ^close^ quickfix list                                 | <
  | $:$[%n%]$cn$ext                 | ^goto^ %nth next% $entry$ in quickfix list                | <
  | $:$[%n%]$cp$revious             | ^goto^ %nth previous% $entry$ in quickfix list            | <
  | $:$[%n%]$cnf$ile                | ^goto^ %nth next% $file$ in quickfix list                 | <
  | $:$[%n%]$cpf$ile                | ^goto^ %nth previous% $file$ in quickfix list             | <
  | $:cfir$st                   | ^goto^ %first% $entry$ in quickfix list                   | <
  | $:cla$st                    | ^goto^ %last% $entry$ in quickfix list                    | <

# Files > Rum command across collections

  • We know how to run command in file <
  • How can we run command in a collection of files? <

  | Command             | Description                                  | <
  | ------------------- | -------------------------------------------- |
  | $:$[%range%]$bufdo$ {$cmd$} | ^run^ $cmd$ on %range% in $buffer list$              | <
  | $:$[%range%]$argdo$ {$cmd$} | ^run^ $cmd$ on %range% in $argument list$            | <
  | $:cdo$ {$cmd$}          | ^run^ $cmd$ on each $entry$ in $quickfix list$       | <
  | $:cfdo$ {$cmd$}         | ^run^ $cmd$ on each $file$ in $quickfix list$        | <
  | $:ldo$ {$cmd$}          | ^run^ $cmd$ on each $entry$ in $location list$       | <
  | $:lfdo$ {$cmd$}         | ^run^ $cmd$ on each $file$ in $location list$        | <
  | $:$[%range%]$windo$ {$cmd$} | ^run^ $cmd$ on %range% in $each window$              | <
  | $:$[%range%]$tabdo$ {$cmd$} | ^run^ $cmd$ on %range% in $each tab$ (active window) | <

# Thanks

{{{ascii
 QQQ   U   U EEEE  SSS  TTTTTT III  OOO  N   N  SSS   ???
Q   Q  U   U E    S       TT    I  O   O NN  N S     ?   ?
Q   Q  U   U EEE   SSS    TT    I  O   O N N N  SSS     ?
Q  QQ  U   U E        S   TT    I  O   O N  NN     S   ?
 QQQQ   UUU  EEEE SSSS    TT   III  OOO  N   N SSSS    ?
     Q
}}}
