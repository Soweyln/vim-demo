$MASTER VIM THE EASY WAY$

- Bin

# About

  • Covers Vim essentials <
  • Covers many useful tips <
  • Helps you to be a Vim master <
  • Does NOT make you a Vim master (Practice!) <
  • Covers only small portion of Vim's power <
  • Vim is just one part of the flow <


# What is Vim?
{{{ascii
            _______ ________   _________   ______ _____ _____ _______ ____  _____
    /\     |__   __|  ____\ \ / /__   __| |  ____|  __ \_   _|__   __/ __ \|  __ \
   /  \       | |  | |__   \ V /   | |    | |__  | |  | || |    | | | |  | | |__) |
  / /\ \      | |  |  __|   > <    | |    |  __| | |  | || |    | | | |  | |  _  /
 / ____ \     | |  | |____ / . \   | |    | |____| |__| || |_   | | | |__| | | \ \
/_/    \_\    |_|  |______/_/ \_\  |_|    |______|_____/_____|  |_|  \____/|_|  \_\
}}}

# Why Vim?

  ## Efficiency <
    • No mouse
    • No ambiguity
    • Powerful modal editing
    • Designed for DRY (_Don't Repeat Yourself_)

  ## Performance <
    • Lightweight

  ## Customization <
    • Config
    • Plugin
    • Script
    • Integration

  ## Documentation <
    • Comprehensive documentation

# How to Start?

  ## Touch Typing <
    • The foundation <
    • Practice more for numbers and special characters

  ## Vimtutor <
    • {{{sh $ vimtutor }}}

  ## Minimal Config <
    • Minimal .vimrc config to start with

    {{{vim " .vimrc
    set nocompatible
    syntax on
    filetype plugin indent on }}}

# How to Start?

  ## The Very Essentials <

  | Command          | Description                                 | <
  | ---------------- | ------------------------------------------- |
  | $h$, $j$, $k$, $l$       | move $left$, $down$, $up$, $right$                  | <
  | :w               | $write$ to file                               | <
  | :q               | $quit$                                        | <
  | :q!              | $quit$ (discard changes)                      | <
  | :e {file}        | $edit$ file                                   | <
  | :e {dir}         | open $dir$ in file browser                    | <
  | $w$                | move to the %next% $start of word$              | <
  | $b$                | move to the %previous% $start of word$          | <
  | $$$                | move to the $end of line$                     | <
  | $0$                | move to the $beginning of line$               | <
  | $gg$               | move to the $first line$                      | <
  | $G$                | move to the $last line$                       | <
  | [n]$gg$            | move to $line$ %{n}%                            | <
  | $<C-d>$            | move $half page down$                         | <
  | $<C-u>$            | move $half page up$                           | <
  | $i$                | $insert$ %before%                               | <
  | $<ESC>$            | return $to Normal mode$                       | <
  | $dd$               | $delete$ %current line%                         | <
  | $dw$               | $delete$ until %next start of word% (exclusive) | <
  | $u$                | $undo$ last edit                              | <
  | $<C-r>$            | $redo$ last edit                              | <
  | $yy$               | $yank$ %current line%                           | <
  | $p$                | $paste$ %after%                                 | <
  | $/${p}$<CR>$         | $search$ forward                              | <
  | $:%s$/old/new/[gc] | $substitute$ in file                          | <

# Contents

  • Modes <
  • Move <
  • Edit <
  • Visual <
  • Command <
  • Repeat <
  • Search <
  • Files <
  • Config <
  • Plugin <
  • Script <

# Modes

  • Normal <
  • Insert <
  • Command-line <
  • Visual <
  • Operator-pending <
  • Replace <

# Modes > Switch between Modes

  • Vim is in $Normal$ mode when it launches. <
  • We can switch between different modes <

  | Command                    | Description                     | <
  | -------------------------- | ------------------------------- |
  | Normal + $a/A/C/i/I/o/O/s/S$ | switch to $Insert$ mode           | <
  | Normal + $:$                 | switch to $Command-line$ mode     | <
  | Normal + $v/V/<C-v>$         | switch to $Visual$ mode           | <
  | Normal + $c/d/y/v$           | switch to $Operator-pending$ mode | <
  | Normal + $R$                 | switch to $Replace$ mode          | <
  | ANY + $<ESC>$                | back to $Normal$ mode             | <

# Move

  • Moving around is one $crucial$ part of the flow when using Vim <
  • Avoid using $arrow keys$ to move <
  • Avoid move in $Insert$ mode <
  • Better to avoid using %repeated% $h/j/k/l$ to move <
  • Most moves can be repeated by $count$ <

# Move > Move by direction

  • $h/j/k/l$ can be repeated by $count$ <

  | Command | Description               | <
  | ------- | ------------------------- |
  | [n]$h$    | move %n% $character(s) left$  | <
  | [n]$j$    | move %n% $line(s) down$       | <
  | [n]$k$    | move %n% $line(s) up$         | <
  | [n]$l$    | move %n% $character(s) right$ | <

# Move > Move by word

  • A $word$ is a sequence of letters, digits, understores or other non-blank characters. <
  • It can be customized with $iskeyword$.
  • Move by $word$ is useful and much faster than move by single character.

  | Command | Description                            | <
  | ------- | -------------------------------------- |
  | [n]$w$    | move to the %nth next% $start of word$     | <
  | [n]$b$    | move to the %nth previous% $start of word$ | <
  | [n]$e$    | move to the %nth next% $end of word$       | <
  | [n]$ge$   | move to the %nth previous% $end of word$   | <

# Move > Move by WORD

  • A $WORD$ is a sequence of non-blank characters separated by white space. <
  • Move by $WORD$ is preferred in certain cases.

  | Command | Description                            | <
  | ------- | -------------------------------------- |
  | [n]$W$    | move to the %nth next% $start of WORD$     | <
  | [n]$B$    | move to the %nth previous% $start of WORD$ | <
  | [n]$E$    | move to the %nth next% $end of WORD$       | <
  | [n]$gE$   | move to the %nth previous% $end of WORD$   | <

# Move > Move in line by line boundary

  • Move using $$$, $0$, $^$ is a quicker way to navigate to / between ends of current line. <

  | Command | Description                                                  | <
  | ------- | ------------------------------------------------------------ |
  | [n]$$$    | move to the $end$ of %(n-1)th next% line                         | <
  | $0$       | move to the $beginning$ of line                                | <
  | $^$       | move to the $first non-blank character$ of line                | <

# Move > Move in line by finding character

  • Move using $f$, $t$ is a more precise way. <
  • Be aware of the $choice$ of {c}.

  | Command | Description                                                      | <
  | ------- | ---------------------------------------------------------------- |
  | [n]$f{c}$ | move %to% the %nth% $next occurrence$ of {c} in line                   | <
  | [n]$t{c}$ | move %till% the %nth% $next occurrence$ of {c} in line (exclusive)     | <
  | [n]$F{c}$ | move %to% the %nth% $previous occurrence$ of {c} in line               | <
  | [n]$T{c}$ | move %till% the %nth% $previous occurrence$ of {c} in line (exclusive) | <
  | [n]$;$    | $repeat$ last find %n times% in line                                 | <
  | [n]$,$    | $repeat$ last find %n times% in line in %opposite direction%           | <

# Move > Cursor and Window

  • $Cursor$ position vs $Window$ position <
  • Vim always make sure cursor is $inside$ window <
  • The window position depends on $scrolloff$ config <

# Move > Move in file by line

  • Use $gg$ or $G$ to move to line <

  | Command | Description            | <
  | ------- | ---------------------- |
  | $gg$      | move to the $first line$ | <
  | $G$       | move to the $last line$  | <
  | [n]$gg$   | move to $line$ %{n}%       | <
  | [n]$G$    | move to $line$ %{n}%       | <

# Move > Move by window

  • Move faster by window <
  • More useful to $navigate$ rather than position
  • Harder to interpret the exact position

  | Command | Description                           | <
  | ------- | ------------------------------------- |
  | $<C-d>$   | move cursor $half page down$            | <
  | $<C-u>$   | move cursor $half page up$              | <
  | $<C-f>$   | move %window% $one page down$             | <
  | $<C-b>$   | move %window% $one page up$               | <
  | $H$       | move cursor to $"first line"$ in %window% | <
  | $M$       | move cursor to $middle line$ in %window%  | <
  | $L$       | move cursor to $"last line"$ in %window%  | <

# Move > Move by object

  • Move by sentence and paragraph <

  | Command | Description                                 | <
  | ------- | ------------------------------------------- |
  | [n]$($    | move to the %beginning% of $previous sentence$  | <
  | [n]$)$    | move to the %beginning% of $next sentence$      | <
  | [n]${$    | move to the %beginning% of $previous paragraph$ | <
  | [n]$}$    | move to the %beginning% of $next paragraph$     | <

# Move > Move by search

  • We can also use pattern search to move around <
  • More in $Search$ section

  | Command  | Description                           | <
  | -------- | ------------------------------------- |
  | $*$        | $search forward$ for %word% under cursor  | <
  | $#$        | $search backward$ for %word% under cursor | <
  | $/${p}$<CR>$ | $search forward$                        | <
  | $?${p}$<CR>$ | $search backward$                       | <
  | $n$        | move to the $next match$                | <
  | $N$        | move to the $previous match$            | <

# Move > Move by match

  • We can also move around using $([{$ semantics <

  | Command | Description                                          | <
  | ------- | ---------------------------------------------------- |
  | $%$       | find $([{$ in line and move to the %matching close%      | <
  | $[{$      | go to previous $unmatched {$ (%beginning% of code block) | <
  | $]}$      | go to next $unmatched }$ (%end% of code block)           | <
  | $[($      | go to previous $unmatched ($ (%beginning% of func param) | <
  | $])$      | go to next $unmatched )$ (%end% of func param)           | <

# Move > Move by mark

  • Mark is useful for remember a location <
  • Take advantage of special marks

  | Command | Description                             | <
  | ------- | --------------------------------------- |
  | $m${mark} | $add$ a mark                              | <
  | $`${mark} | $goto$ a mark (%exact position%)            | <
  | $'${mark} | $goto$ a mark (%first non-blank character%) | <

  | Marks  | Description                              | <
  | ------ | ---------------------------------------- |
  | ${a-z}$  | $local$ mark in file                       | <
  | ${A-Z}$  | $global$ mark                              | <
  | $.$      | $last edited$                              | <
  | $'$      | $latest jump$                              | <
  | $`$      | $latest jump$                              | <
  | $"$      | $last position$ before leave buffer        | <
  | $^$      | $last insert$ position                     | <
  | $[$      | %beginning% of $last changed or yanked$ text | <
  | $]$      | %end% of $last changed or yanked$ text       | <
  | $<$      | %beginning% of $last visual select$          | <
  | $>$      | %end% of $last visual select$                | <

# Move > Move by jump

  • $jumplist$ maintains jumps history, we can use it to jump back and forth <

  | Command | Description                        | <
  | ------- | ---------------------------------- |
  | $<C-o>$   | jump to $older$ position in %jumplist% | <
  | $<C-i>$   | jump to $newer$ position in %jumplist% | <
  | $:jumps$  | list $jumps history$                 | <

# Move > Move by change

  • $changelist$ maintains changes history, we can use it to jump back and forth as well <

  | Command  | Description                          | <
  | -------- | ------------------------------------ |
  | $g;$       | jump to $older$ position in %changelist% | <
  | $g,$       | jump to $newer$ position in %changelist% | <
  | $gi$       | %insert% at $last insert position$       | <
  | $:changes$ | list $changes history$                 | <

# Thanks
